**************************
* kIss - keep It...  :-) *
**************************

***************** 2024 ***************** 

is that it? Its.

todo: 

translate CMTN "crawler" logic into CMTN-chatbot, spiral means...?
phase shift, 0 -> 100% -> 0 -> 100
3 diff "tuners" with slightly diff freq. would eventually go through all the combinations!

1) save ideas.txt to github and LLMs
2) specific applications, where? LLM optimization? Search optimization? or is it too complicated? 
   need simple task, solvable in 1 year:

     Single 1-bit channel , 1 In/2 Outs
     multi-frequency      , >= 3
     self-tuning/SSL      , continuous
     simple GF            , non-academic task, practical, beneficial, $
                            expandable (with more channels/etc), can be solved in some other way 
                            but longer/expensive/direct modelling
                            as we compare CMTNs to ML/LLM, looks like the task should be from that domain 
                            for comparability, prediction task - chatbot-related
                            target - finding temporal symmetry in a continous process

                            chatbot-CMTN can SSL multiple channels, so maybe let's limit frequency to 1 
                            for simplicity? Each channel regulates separate LLM prompt temp to gain max 
                            customer satisfaction based on live feedback from bot (thumbs-up/down icons) or
                            offline chatbot log sentiment/tone/events (escalations) analysis.
                            There may be a few LLM prompts and some of them "inversed" relative to the goal
                            so less temp - better GF. Reason - chatbot performance is super-dependent on 
                            temp settings and not really obvious what it should be in design time,
                            maybe site-dependent or else (.ai settings != .org).


3) plan NNN MVP, design, resources, timeline, users (need some traction)
   core engine / test framework / prod wrapper (instances) / connectors (3rd party, dialogflow...)
4) prepare elevated pitch to angels (use comparison table below, use #2 for 'ask', specific applications)
   "start with LLM/GPT boxes vanishing..."
5) polish pitch and run by ...


compare CMTNs with ML/GenAI:

a) "scientific method" use in ML (plain, random?)     vs  CMTNs (optimized, know direction)
b) show unrelated images to train for classification  vs  coherent "living/travel/exploration" experience
c) passive (no goals)                                 vs  proactive (survive, food)
d) convolutional or other non-spiking network         vs  spiking (similar to...)
e) planning and reasonning - extra layers (JEPA or..) vs  embedded
f) SSL - pretext task is often arbitrary              vs  pretext task = main task = survival (evolutionary goal)
g) energy consumption - high or very high (GenAI)     vs  low (computational approximation for NP-full tasks)



***************** Jan-Mar 2024 ***************** 

first-last call.

can we implement it? weak-to-strong generalization, interpretability, scalable oversight, RLHF, etc

we need learning, SSL or else, anything! LLM has no goal (hunger, etc), prediction - means to reach goals
we need prediction in the same way. association~learning=prediction. 

association - same schema but 2 Ins and react to delay in between. Optimization/association.

actually association!=learning as we can start learning even with 1 In!
learning = how we react to In with Out1/Out2 or reversed Out2/Out1! (polarity / phase)
"food - eat", but "danger - run away"

what we are learning, variables: polarity -> amplitude-frequency-combo (CMTN unqiue metrics) -> phase (?)
                                 ending with the biggest one - polarity

how we are learning: pre-Hebbian rule (as we only have 1 In) 
                     ^^^^^ not true, in min implementation (lower level) - 2 Ins per Out for looping (GEN) 
                     ^^^^^ thus we can change polarity
                     taking feedback from longer period CMTN on the same channel, negative - apply changes
                  or taking feedback from longer period CMTN on the main channel (hunger, etc)? 
                     in simple system all channels = main/basic instinct channels
                     maybe mixing slow signal from there into the channel? or both? or?

how we are learning: slightly adjusting delays in base GENs we can affect resulting frequncy 
on lower level       in relatively wide range
                     it's easier to reduce freq. by adding extra GENs
                     I don't think GENs are removed at all actually? grow only policy, learning - growing
                     but we can also increase freq. by adding extra GENs! example: 6x5=30 -> 6x5x3=6

learning = when negative feedback stimulates growing in certain areas. 

now associations:    if we know how to react to one In1, then we second In2 is added, we would keep
                     reacting in the same way & also start reacting to In2/In1 sequence, where In1 - main.
                     but delay should be min, so for longer assoc. we need to add long delay circuits,
                     so at the cell all signals are almost simultaneous.
                     Anyway it's like adding secondary options, confirmations, thus 'associations'! 
                     pure Hebbian rule in action. 1) Out is synced with In1  2) Added In2  
                     3) Out will sync with In2 too after some time if In1 and In2 are in sync

Hebbian rule in details:
the higher signal freq on one particular In, the more chances it would trigger the Out => our freq rule!
Out freq is always less than In (at least /2)
"last drop" is the most important, could be several last drops (combination-association)

now whole picture - ? SSL, while learning is growing, I don't think in case of extended food absense
we're doing that (counterproductive), likely just change freqs. But maybe it's counterintuitive as
simple freq changes may adapt to new env, but what about old habits? 
learning must be cummulative, it's not good to forget things, unless it's bad/wrong accociations.

compromise - we're growing new cells while Gf+ is good, but they are flexible for some time and
adapting to new patterns, not nessesary when Gf- just finding new patterns is always beneficial.

logic:

-grow extra flexible CMTNs (initially just in parallel)
-get negative feedback (from ..., initially Gf- from longer period CMTN, food)
-keep existing CMTNs network, rigid stucture;
-adjust flexible CMTNs params;
-how? totally randomly or ... or look at backprop alg?
all education - 
a) with teacher by example 
b) self learning:
-random try and error 
-others try, I learn
-educated try and error - same scientific method! That's it. Higher level recursion. <=================

learning is guided by the same evolutionary fine tuned logic - adjust fast/slow down/pivot.
learning, it's like temp-y we soften the structure, find "sweet spot" and make it rigid again

but we need to change several options - see above, polarity, freq In, freq Out 1, freq Out 2, etc..
each one is controlled with a separate CMTN level 2 "guide"? 
well, technically freq In, freq Out 1, freq Out 2 are interdependent, so need to adjust just one?
what about more complex "slow" CMTN with many elements?

if we "soften the structure" (above) all GENs within complex CMTN start playing "offtune"
maybe each one randomly as we don't know how to react in changing env, go with lower freq or higher...

so learning still implies slightly diff. "implementation", with the same logic,
scientific principle (augmented, CMTN) for controlling nodes, but they are not affecting OUTs, 
rather affecting "structure" itself (analogy - chemical neurotransmitters vs electrical signals?)

we have three networks:
a) existing (fixed, trained)
b) new, duplicates of existing (flexible, learning)
c) control, same logic but long period and affecting those new networkS, making them more flexble/fixed


if duplicates are in counterphase this might work even without "filters", just producing valid "tracking"
wave by adding diff freq. from 2 counterphased-CMTNs! so we don't really need filters!

but need to test it! test! test! test! verify!
btw, may be INV should react to two (2) signals, not stopping immediately on the 1st (current low level impl),
so it's enough to measure "frequency" (any 2 signals define frequency, not 1)
actually it's ok and low level designed correctly!
besides testing, what else ?

growing connectivity rules? new cells, (b) should try to connect to all previous (a) for versatility
and then with time only strong connections (Hebb) would persist.


***************** Sep 2023 ***************** 

Develop a Minimum Viable Product (MVP) for AutoGPT - "GeNNN" / Generative Search: 
grants, competitions, crowdfunding, or accelerators and incubators that support early-stage startup

Google cloud free e2-micro instance
or https://nonprofit.microsoft.com/en-us/getting-started ? need 501c3
MS offering is better

Use Django for web embedded plugin development https://ai-wrapper-djan.lampbuilder.com


NEED more practical thinking:
is there a way to apply NNN flow to GenAI flow? Kind of guided Auto-GPT with clear tracking
search (find precise answer) and expanding (no useful data found) spirals?

GF   - Closer/Further       - 'limited volume, max info'?
Move - Left/Right/Fast/Slow - antonyms?  and LLM prompt "Expand/Reduce" should/could be used as "pulses"
                                         with diff freq? like Expand x3 & Reduce x4 ?
                                         so Expand/Reduce is not really analogous to L/R?
                                         maybe we need to add those qualifiers to each request like:
"now build web site content AND Expand AND Beautify"
"now build web site content AND Expand AND Beautify"
"now build web site content AND Reduce AND Beautify"

how do you do 2D spirals: use 2D axis movements at the same time, Expand-Reduce & Beautify-Disarray

                           Min Expand & Reduce, Max Beautify
                          /                                 \
 Max Reduce, Min Beautify                                     Max Expand, Min Beautify
             Min Disarray \                                 /             Min Disarray
                           Min Expand & Reduce, Max Disarray

0,1 -> 1,0 -> 0,-1 -> -1,0 ->...

0 -> 1 -> 0 -> -1 -> 0...
     1 -> 0 -> -1 -> 0 -> 1...


should axis be orthogonal (and the same units) or at least unrelated/correlated??
btw, Size & Beautify are kind of related, the less is more ;-)

how do you do 3D spirals: use 3D axis movements with phase shift, Expand-Reduce & Beautify-Disarray & Validate-Question

0 -> 1 -> 0 -> -1 -> 0...
     1 -> 0 -> -1 -> 0 -> 1...
          0 -> -1 -> 0 -> 1 -> 0...

0,1,0 -> 1,0,-1 -> 0,-1,0 -> -1,0,1 -> 0,1,0 ->...

-not only phase shift, but slightly diff periods to produce more variations/combinations
-and then increase temp / slow turning for spiral
-we don't need a lot of 'variables', 3-5-7 are good from practical perspective

how do we evaluate responses? GF ideally +-1 / either other LLM or operator
solve simple task initially, 2 variables-axis / 1 feedback GF. Task examples?

a) same (GPTs) training course optimized by price (low-high) and length (short-long)?

b) find a gift optimized by price (low-high) and rating?

c) any security-oriented examples?
choose agent/sensor's set of options optimized by workstation performance and security value?

d) best demo example (reliable)?


control is always continuous function

Analyze - Describe / Compare - Isolate      / Correlate - Disassociate / Illustrate - Abstract 
Infer - State      / Predict - Recapitulate / Synthesize - Segment     / Validate - Question



start with GF:
user asks LLm question and so defines a vector of "auto-completion" direction
Auto-GPT guided by "digital double"?

===> learning is TUNING? just freq tune each CMTN to play organically as an orchestra?
===> and CMTN idea is just an extension to ML idea (hypothesis -> action -> keep/abandon)

=> learning and making an associations is the same thing?
so a) first we need to enchance our model - as min 2 Ins required for associations 
      (we have 2 "same" Ins with temporal diff)
   b) besides '+' add '-' association (food / pain)

=> don't use low level elements for now, focus on high level logic & associations
   and how this can be translated into Auto-GPT architecture

q1: how do we translate "frequency"?  more dense in data stream / often out, corrective actions? (L/R)
problem: LLms are reactive, not proactive, not generating text all the time
         diff LLLm - diff text generation speed.
but for LLM "frequency" in context means diff things? Like for "expand description" task goal / "frequency"
is more raw data output [bytes], but for "shrink description" - totally opposite!

q2: LLM corrective actions may be different for every task, like "expand/shrink description" or 
"use more/less advanced terminology", etc or combined (one, then other) or mixed (one and another)
or may be non-verbal guidance, like set LLM temp?

I guess it should be just a set of diff CMTNs? Like

-------------> CMTN1 -----> L  expand description
size of              -----> R  shrink description
Child LLM produced data

-------------> CMTN2 -----> L  use more advanced terminology
terminology          -----> R  use less advanced terminology
used in Child LLM produced data



1) CMTN1

   If In1 freq < const11, Out1 = const11, Out2 = const12  Fast R
   else          1000     Out1 = const13, Out2 = const14  Slow L

   If In1 freq < const21, Out1 = const21, Out2 = const22  Fast R  reverse
   else          100      Out1 = const23, Out2 = const24  Slow L  reverse

   If In1 freq < const31, Out1 = const31, Out2 = const32  Fast R  reverse
   else          10       Out1 = const33, Out2 = const34  Slow L  reverse

2) CMTN2, use low level FLT?


For later:
NEED experimentation:  (hold on for now)
MODEL with NEURON, NEST, cloud-based tools like "Open Source Brain"  
https://www.opensourcebrain.org  OSBv2 
https://v2.opensourcebrain.org/workspace/open/884/netpyne
https://docs.opensourcebrain.org/OSBv2/NetPyNE.html#osbv2-applications-netpyne

***************** Jul 2023 ***************** 

Decomposition complete, reached the bottom, CMTN/INV. Genesis (shown once, further below).
Spatial/temporal symmetry. GF starting / synchronizing LD-CMTN, off-tune to be in-tune.

Composition:
Use freq range camertones to work in groups on the same channel (combine low/high camertones).
Use low frequency filter when needed for that.

it seems like we need to build large network on the same principles as base element - cell/neuron
but for wider range of signals (slower and very slow)

How to combine FLT and CMTN to build 2 freq "tuner" on the same In? freq. matrix? they are independent?
CMTN1 > GEN1

						  30 < In2 <  100  generate L2   0 ?   counter phase?
  0 < In1 <  30  generate L1 30			  30 < In2 <  100  generate L2 100
 30 < In1 < 100  generate R1  2			 100 < In2 < 1000  generate R2  20
100 < In1        generate     0			1000 < In2         generate      0




        ----> FLT1  (30) --->+ GEN1 (5) ---
       /                     -/            \
      / ----> CMTN1 (20) --------------------->
_____/_/
     \ \
      \ ---> FLT2
       \
        ---> CMTN2



Think about how GF both +1 and -1 affect on a) association. b) neuroplasticity and GEN <-> GENS flips  c) ssl
layers buildup - from fast to slow? seems like it.
? => and now we need to understand how with simple 2 freq range camertones combo (like 1000/10 Hz)
     we can max food findings, reacting to both high freq (solids) and low changes in high freq (groups 2nd level)
     we need filter may be? not "low frequency filter" as above but filter averaging signal?
     or split wave into spectrum? or just simple "running average"? (this is how cells work actually)
     so may be we need to compare with previous period? small1 vs small2 / long1 vs long2
     can camertones do that? filters combined with camertones:

	compare (FLT, t1 + period * 0) -> 0
		(FLT, t1 + period * 1) -> 1
		(FLT, t1 + period * 2) -> 0 and built hierarchy! feed it to CMTN/CMTNS

	very important to set "cutoff freq level" so we would get 1/0 mix, not just 0/0/0 or 1/1/1/1
	this is our "mid-term" goal

	Still q: long perod filters? Simple delay doesn't help. Well, it does work but no error margin.
	the main problem is to notice when we get signals > frequent. Easy?

	 ----> long delay ---->A CMP   first B signal would reset CMP, after that check what is first A or B? 
	   \__________________/B

===> 	FLT should work for long delays too, even there's some variability at final "summator" element 
	but we can combine FLT level 1 and 2 like this:

      FLT1		FLT2

       |
     --c---           ---------------> FLT1 --> time compressed sparse signals 
F1  |  |   |         |   |   |   |
 ->--c-->c--        -->C-->C-->C--

  c - cell/short    C - CMTN long
      delay             delay

	and run them in parallel to find better one, like for CMTNS
	still it's reacting to natural harmonics only, f, f * 2, f * 3, f * 4...  
	missing floating  f * 2.2, 3.3  what seems ok? due to saturtion after certain level like 4 / 4.5 / 5
	all might work ok as diff is waning

short term associations - at cell level (Hebbian rule)
long term - need delays and that's it? still absolute sync with long delays seems unlikely
better use trigger like below (MEMC) reacting to sequence



          (GEN/GENS)                                     (CMTN/CMTNS) camertones


            min delay, 2-3-5-7 ticks            
           -----<-----                           -->+ GEN1 period1 ---->
          |           |                         /                       \+                      
      In3  --> +      |                       ----->+ GEN2 period2 ----> + Cell ----->          
 In1 --------> + Cell1 ---------                \                       /+             
 In2 --------> -                                 -->+ GEN3 period3 ---->               


          (INV), invertor                                (TRK), tracker, min


                                                 --------------> + CMTNS2 -->  Out1'----
  ----> CMTN --->+ Cell1 --------->             /              / -                      \
    \            -                           ------------------> + CMTNS1 -->  Out1 \    \
     ----------->                               \             /  -                   ---  \___
                                                 ----> Inv1 ---------------->  Out2 / O1  / O2
                                                  \          /                           /
                                                   --> Inv2 ---------------->  Out2'-----


          (FLT), low frequency filter


       |F1 when  F1 > C, ignores all signals
     --c---
F1  |  |   |  
 ->--c---c--



***************** Apr 2023 ***************** 

Simple case, two camertones:
(a) tuned to 50Hz,  producing 50/70   Hz - 10/15 Hz    optimized for low  density env
(b) tuned to 500Hz, producing 500/600 Hz - 70/80 Hz    optimized for high density env

q. - how to choose the right one for current environment? rather:
q. - what combined behaviour would be evolutionary beneficial? 
like running (a) on low density and (b) on high density, but:
q. what about crossovers - low for (a) may be high for (b)?
we can only run models in parallel but should be in sequence?
q. better - we should run them in a way of increasing evolutionary advantage! how? model it for example.
   may be:

     x > 500 Hz - high camertone on 70/80 speed
50 < x < 500 Hz - high camertone on 500/600 speed or low camertone on 10/15 speed?
0  < x < 50  Hz - 

maybe there should be narrow range like high density env for 400-700 Hz, low density env for 40-60 Hz
like real camertone? problem - grey area, 60-400 then what?
a. this may be ok, as we can define any range
a. looks like combining camertones and reversed camertone we can define a proper range!!!

problem - need reversed logic too, to start GEN above certain frequency
a: this seems to be biological based - signals fade?
no, can do it simple way:

       |F1 when  F1 > C, ignores all signals
     --c---
F1  |  |   |  
 ->--c---c--

C is either cametrone (in delay mode) or linear "delaying" multi-cells
problem: it will be reacting to F1 and natural harmonics only F1*2, F1*3...
?what is the diff between 2 and 3, 4 more elements?
improves reliability / freq range of reaction / and faster reaction to higher freq.


think about cindarian conditioning and STDP
seem like STDP learning (event association) != 2 Ins with delay learning as the first one may only
work for short delays and second one for any delay


Is the model compositionally complete? Seems like it with addition of memory as we can start/stop any freq
and cover the full 2D to find food sources.

Training & composition / is 2nd IN and association needed too?
maybe 2nd IN - is our "trainer"?

ANN | SNN | RNN | NNN, unsupervised learning

What is training in general? "evolutionary trained" => improve it, how?
What is learning? in general for us. Better results with time. (err func -> min)
what time? maybe we can do self-optimization with EVERY turn?

Genesis: 
non-adaptable hardcoded structure, fixed freq -> 
adaptable system, variable freq -> 
self-teaching system, fixed after training or not ("Liquid networks" by Ramin?)

changes during self training - mostly "tracking" periods as other periods are derived

but technically we shouldn't change existing "net of CMTNs" just build on top of it. learning = growing
so how do we find 2nd degree freq? this is the same as 2nd level sym
maybe we always create CMTNs & CMTNsx10 (slower) at the same time? Just in case, to find that 2nd level?

how:
1) don't forget what was learned before or maybe? if it was ok, but now is not?
2) build on top of that.

=> learning and making an associations is the same thing?
so a) first we need to enchance our model - as min 2 Ins required for associations 
      (we have 2 "same" Ins with temporal diff)
   b) besides '+' add '-' association (food / pain)

=>> train simplest system 1st 2nd 3rd degree symmetry



maybe there's always second level created along with the first one (x10|x100), which controls
plasticity of the first one if not reached?  if '-' issuing fast corrective signals, '+' slow

or second level may be created not from the same type of In (x10|x100), but different In, not 'food'
but 'pain' or else (same level x1), so this is 'association'?



stages - tune tracking / tune 'starvation' spiral / tune 'satiation' spiral

1) self-tuning to 1st symm level by (in priority order):
   a) adjusting time delays a bit
   b) converting GEN <-> INV both ways
   c) adding more GEN/INV


2) self-tuning to 2st symm level by:
   a) adding more GEN/INV (much slower)
   b) goto #1?



***************** Feb 2023 ***************** 

Decomposition complete, reached the bottom, CMTN/INV. Genesis (shown once, further below).
Spatial/temporal symmetry. GF starting / synchronizing LD-CMTN, off-tune to be in-tune.

(GEN/GENS) delay >> refractory / delay ~= refractory period


            min delay, not anymore, so stop is more challenging, albeit just 2-3-5-7 ticks)
           -----<-----                      
          |           |                     reaction to In1 is strongest, while to In3 only if no recent In1
      In3  --> +      |                     this is "plasticity"
 In1 --------> + Cell1 ---------   
 In2 --------> -                   two attributes - delay & refractory period (time before can be triggered again)

            Stop signal (optional), no separate name for this configuration


(CMTN/CMTNS) camertones, are being built on GEN/GENS correspondingly

                               
     -->+ GEN1 period1 ---->                        *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
    /                       \+                      *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *    *
  ----->+ GEN2 period2 ----> + Cell ----->          *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *    
    \                       /+             
     -->+ GEN3 period3 ---->               


(INV), invertor

                                
  ----> CMTN --->+ Cell1 --------->  
    \            -                   
     ----------->                  


(TRK), tracker, min


      -----------------> + CMTNS2 ----->  Out1'------
     /                 / -                           \
  ---------------------> + CMTNS1 ----->  Out1 \      \
     \                /  -                      -----  \____
      ------> Inv1 -------------------->  Out2 /   O1  /  O2
       \             /                                /
        ----> Inv2 -------------------->  Out2'-------

timing diagram (example, explaining why timing is everything): 

1. no signals for 30 sec
2. start generating first Out2 with periods of 30 sec, cancelling Out1
3. no signals for 35 sec
4. start generating Out2' with periods of 35 sec, cancelling Out1'
...
600 sec later (generated 20 waves)
...
5. got first In signal at 601 sec
   this is cancelling    both Inv1/Out2 & Inv2/Out2' with periods of 30/35 sec, but no Out2/Out2' at this moment!
   this is also starting both CMTNS1/Out1 & /CMTNS2/Out1' with periods of 100/120 sec, got first Out1/Out1' 
6. got second In signal at 602 sec or 605 sec or 629 sec
   this is cancelling    both Inv1/Out2 & Inv2/Out2' ....... again, no Out2/Out2' 
   this is not affecting CMTNS1/Out1 & /CMTNS2/Out1' with periods of 100/120 sec, still no Out1/Out1' at this moment
...
we need to keep getting at least 1 signal within 30 sec for CMTNS1/CMTNS2 to start producing "slow wave"

7. 700 sec start seeing first "slow wave" signals


(TRK), tracker, multi-level

        ------------------> + CMTNS4 -->  Out1''' loweset
       /                 / -
       ------------------> + CMTNS3 --->  Out1''  lower freq
      /                 / -
      ------------------> + CMTNS2 ---->  Out1'   lower freq
     /                 / -
  ---------------------> + CMTNS1 ----->  Out1
 In1 \                /  -
      ------> Inv1 -------------------->  Out2
       \
        ----> Inv2 -------------------->  Out2'   lower freq
        \
         ---> Inv3 -------------------->  Out2''  lower freq
         \
          --> Inv4 -------------------->  Out2''' loweset



        /
  ------
 In2 


q#1: fastest Inv, Inv1 can stop all CMTNS? or for reliability all Invs can do it? all, and not for reliability
     but for smooth reaction, each Inv should stop only corresponding CMTNS
a:   stopping all is ok as a new Out cycle is "increasing", not "instant", 50% power... 75%.... 87%...

q#2 how to combine with In2/In3, etc? smth below?
q#3 (and q from below):

==> as explained below (2021-2022) best behaviour - quick expanding spiral when nothing is found and slow collapsing
==> spiral when "found" something. So Out1 and Out2 outputs are generally unrelated and not easy "swappable".
==>                 actually the other way around - slow expanding spiral / quick collapsing!

still not sure if it should be one way or the other way around? TRK is for second case, any way to reverse?
maybe BOTH tactis are valid for certain conditions?




***************** Jan 2023 ***************** 

Decomposition complete, reached the bottom, CMTN/INV. Genesis.
Spatial/temporal symmetry. GF starting / synchronizing LD-CMTN, off-tune to be in-tune.

(GEN)

           min delay
          -----<----- 
         |           |  
    ------->+ Cell1 ---------   two attributes - delay & refractory period (time before can be triggered again)
           /- 
    ------   Stop signal (optional), no separate name

as we departed from "min delay" so stop is more challenging, good thing it's still small, 2-3-5-7 ticks


            min delay
           -----<-----        proper impl.  reaction to In1 is strongest, while to In3 only if no recent In1
 internal |           |                     this is called plasticity!
      In3  --> +      |
 In1 --------> + Cell1 ---------   two attributes - delay & refractory period (time before can be triggered again)
 In2 --------> - 
            Stop signal (optional), no separate name for this configuration


maybe we need diff name when delay ~= refractory period (GENS) and when >> as quite diff use cases / behaviour (GEN)


(CMTN) camertone, generating, reuse the term from (Oct) as more generic

                               
     -->+ GEN1 period1 ---->  
    /                       \+
  ----->+ GEN2 period2 ----> + Cell -----> period1 * period2 * period3 if all prime numbers
    \                       /+             refractory period is minimal 
     -->+ GEN3 period3 ---->               btw, not neccesary prime numbers, just pairwise, like 3 * 8, 8 % 3 != 0
                                                                                    8 16  24  32 40                 48
same CMTN / CMTNS                                                      3 6 9 12 15 18 21  24  27 30 33 36 39 42 45  48

                                                           still 22 x 20 = combined < max 440 as while 22 % 20 != 0 but
                                                           22 % 2 = 0 & 20 % 2 = 0, so reduced to 220 % 20 = 11
                                                                                        440 / 2 = 220 % 22 = 10
                                                           so using all prime numbers is IDEAL, but not mandatory
                                                           realistic min delay 2x3x5x7=210

CMTN  are built on GEN,  delay >  refractory
CMTNS are built on GENS, delay ~= refractory

but looks like we can't use pure CMTNS, need something on top, like INV/CMTN combo because this criteria
"requirements GENSS  - generate wave with periodX, while there's any In during periodX, freq In > limit"
is not satisfied and we need it for multi-level corrections (spiral, not circle).

but maybe that's ok, strong turn from all levels/harmonic as initial reaction and then subside?

last q: how to combine Out1/Out1'/Out2/Out2 so we would see initial tight right (ex) spiral when detecting something
and then it would slowly stretch (still right) until it's straight and then slowly turn left (or not needed?) 

a: with time passing, INVs from higher levels will be adding more harmonics/enery into the turn, 
so if we want for spiral to unwind we need to counter force, cross-inverse Out1 & Out2


(INV), invertor, generating

     CMTN                           
 -------------->+ Cell1 --------->      we can't use pure CMTN as we need to suppress every single In pitch
   \            -                       starting "vibrations", before desync and resync again and again
    ----------->                  


technically INV is not really needed as CMTN is "re-initialized" with every new signal and won't output anything
until complete sync, so only signal with period > freq1 * freq2 * freq3 will trigger output, periodical output!
see comment above - still needed :-)

so - why we need INV and inhibiting Ins at all??? and how to implement "normal" gen - generating signals if
input signals are frequent enough

ans1: can reduce CMTN out freq if GEN3 is linked to '-', not '+'
ans2: set "special" GEN traits - delay being close to refractory period 

requirements INV    - if there's no any In during periodX, generate wave with periodX, freq In < limit
requirements GENSS  - generate wave with periodX, while there's any In during periodX, freq In > limit
(better name?, WAV? GIN? VIN?)


     -->+ GEN1 period1 ---->  
    /                       \-
  ----->+ GEN2 period2 ----> - Cell ----->   ??????? h-ren', start with requirements above
    \                       /-  /            
     -->+ GEN3 period3 ---->   /            
                              /
                      GEN0 ---


      -----------<----------
     /                      |
    -                       |    
 -->+ GEN0 ------>+ Cell1 --------->      h-ren' #2, dumb solution
                  +                       
      CMTN ------>  

 need smth better? with reflections or ?

     -->+ GENS1 period1 ---->  
    /   -                    \+
  ----->+ GENS2 period2 ----> + Cell ----->  refractory period ~= as delay
    \   -                    /+       /      
     -->+ GENS3 period3 ---->        /       
        -                           /
         \     Stop All            /
          -------------<-----------    so won't react to any In after initial until first Out
                                       problem - Out is not super "periodical" as we generate one period and wait


  --------------------->+ CMTNS ------>  Out1
     \                 /-
      ------> Inv -------------------->  Out2


    ------------------->+ CMTNS ------>  Out1
   /                   /-
 ----> CMTN -->+ Cell1 --------------->  Out2    
   \           -       
    ---------->        


the only q if '-' would stop CMTNS - timing, timing, timing!
another q - implement reversed channel out Out1/Out2 - Out2/Out1 with duplication only (swap)?
doesn't look a good idea as Out1 freq != Out2 freq (significantly) and Out1' is derived from Out1, same as Out2' from Out2
and even more:

==> 
==> 
==> as explained below (2021-2022) best behaviour - quick expanding spiral when nothing is found and slow collapsing
==> spiral when "found" something. So Out1 and Out2 outputs are generally unrelated and not easy "swappable".
==>                 actually the other way around - slow expanding spiral / quick collapsing!
==> 

extra reverse channels:

                this  x/- is not really needed, there will be no Out anyway
                maybe just to save energy   

                       when this delay = 2 we will have /2 divider (ex: 21, 42 %2, 63, 84 %2....)
                             |                               if need close freqs, use 2 CMTNS, like 3-7 & 3-10
                     --->+ GENS1 --->+ Cell ---> Out1'
                    /  x/-          /+
    -------------------->+ CMTNS --------------> Out1
   /                   / -
 ----> CMTN -->+ Cell1 ------------------------> Out2    
   \           -       \
    ---------->         \ same here -----------> Out2'

                             
follow-up to "==>": 
In this implementation, out freqs are stable, they are not changing so there will be no spiral, but circle.  
q: how to do spiral? plasticity? 
change GEN freq a little bit with time? this may not really help as results are non-linear, like
4/11 = 44 but 4/12 = 12 and 4/13 = 52 so I wouldn't change CMTN freq
only if we are using 'magic' pair-wise prime numbers, what is tricky and "not simple", why would I change freq like
2->3->5->7->11->13->17->19... and not 2->3->4->5->6->7...

may be we add "extra freq dividers'? like Out1->Out1'->Out1''->Out1'''....

may be a few competing CMTNs, switching? adding harmonics from higher levels?
the problem is that would just increase or decrease "turning radius" so for spiral you need oo levels
really? or there's an alternative? maybe some new elem. or CMTN with positive/negative feedback
increasing period more and more with each cycle?



***************** Oct 2022 ***************** 

spatial/temporal symmetry via SYM elements (internally using MNAND and/or MNOR for all inputs 000 or 111?)
if lasted a few cycles only (avoid randomness insanity)

DO NOT train, just self-train for simplicity (IO=GF). 
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
  all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
  link (N ins, M outs), delayed out for 1 timeslice, can randomly grow/split with freq
  cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow
  reaction to signal and delayed signal - basis for pattern recognition

1 in - 1 out  = random strategy is the best, 0->r, In is disregarded (just energy), just GENSS
1 in - 1 out  = random strategy + temporal gain/loss tracking, to know when to stop/move, GENSS + INV?
1 in - 2 outs = outward spiral is the best, 0->s, -1->r, 1->"downward spiral"/tracking (rough) + stop/move, GENSS + INV? + MEMC
2 in - 2 outs = "outward spiral" / "downward spiral" (smooth) shape tracking, no internal model, 0->s, -1->r, 1->t
		temporal + spacial gain/loss tracking

2 in - 2 outs (stereoscopic vision) is just optimized version of 1 in - 2 outs (better entering phase).
Is that true for all levels or only for the bottom?
btw, "downward spiral" has sine wave as 1st harmonic

[1st level]

different periods ("density") and / or phase shift ("shapes") can be handled with tracking logic:

actually with combo of 2 elements:

2 ins - 1 out
left  gain -> right gain = excite,  sending signals more frequently / in terms of deviation - positive, higher probability
left  loss -> right loss = excite,  sending signals more frequently
right gain -> left  gain = inhibit, sending signals less frequently / in terms of deviation - negative, lower probability
right loss -> left  loss = inhibit, sending signals less frequently

frequency is const / fixed at every level, different between levels


"Implementation III", Level 1 - N, requirements: uniform across levels & min, KISS


It still seems that 2-In schema is just optimization as 2 closeby Ins would effectively be considered as
"2 or more sequential signals" on one In, resulting in "stop activity" output.


Level 1:
                               
  inverted In S/S -------      
                  ----- |      
In1                    ||           
   ------->1 MEMC2 ---> +GENSS --------> MEMC --> [... X times] --> MEMC --> Fr/(X*2)
   \  ---->2      \   / -         \
    \/             \ /             \
    /\              /               ---> MEMC --> [... Y times] --> MEMC --> Fr/(Y*2)
   /  \            / \  -                                            
   ----\-->1 MEMC2 ---> +GENSS ..... reversed out                    
In2     -->2           ||
                   -----|
   inverted In S/S ------


          ||


In1 -->          --> Out1
       \ (CMTN) /
       /        \
In2 -->          --> Out2

(CMTN) Camertone,  is it similar to Count-Min Sketch in any way?


For level #N

(FR) freq reduction != (FD)

In1 ---> MEMC ---> MEMC ---> ...[N times]... ---> MEMC ---> In1 ---> above
In2 ---> MEMC ---> MEMC ---> ...[N times]... ---> MEMC ---> In2 ---> above


(MIX)


In1 ---->(CMTN-1) -----> Out1
    \   /         \   /
     \ /           \ /      
      /             /
     / \           / \
In2 ---->(CMTN-N) -----> Out2



*details*

(MEMC)
         
In       
 ----------> + GENSS --
  |       -> -        |       
  |      |            |
  |     -------------- 
  |    | |  
  |    |  ------------
  |     ---> +        | 
  ---------> +Cell1 -----------------> Out


(MEMC2 = MEMC with splitted Ins), sequence reaction
****to be improved later to react to certain fixed period between signals to reduce noise****
see below INV


.11...                  
          
In1      
 ----------> + GENSS --
          -> -        |       
         |            |
        -------------- 
...1.1 | |  
       |  ------------
In2     ---> +        | 
  ---------> +Cell1 -----------------> Out  ...1...

          
(GENSS)

           min delay
          -----<----- 
         |           |  
    ------->+ Cell1 --------- 
    ------->-

(INV)                   In2
                        ----->- 
           min delay        --+Cell3 -----
          -----<-----      /
         |           |    /
          ->+ Cell1 ---------+ Cell2 -----
                        ---->- 
                        In1

to invert many Ins, need only one GEN! but...
can we simplify INV? yes! looks almost like GENSS now:


              min delay
      min    -----<----- 
     delay  |           |  
 --\----------->+ Cell1 --------- 
     ---------->-

            or even better:
               
    -----------<-------- 
   | min delay          |  
 --|----------->+ Cell1 --------- 
   |            -
    ----------->


can we replace GENSS with INV? or do we need to?


now: can we solve TSP for O(n)?

       5
(1) *-----*  (2)  12341 = 5 + 4 + 6 + 3 = 18 = 14321r best
    |\ __/7\      12431 = 5 + 7 + 6 + 8 = 26 = 13421r
   3| /___  \ 4   14321 = 3 + 6 + 4 + 5 = 18 
    |/   8\ /     14231 = 3 + 7 + 4 + 8 = 22 = 13241r
(4) *------* (3)  13241 = 8 + 4 + 7 + 3 = 22
       6          13421 = 8 + 6 + 7 + 5 = 26

#57, Physarum p, PhP does simple 2 level aggregation? Like each leg has 2 states/action - detract/contract & central
"brain" controls what sides consume more food over time and ask them to detract, others - contract?

So we have 10 CMTN-1-N & 1 central CMTN-C aggregating over time and "side", like CMTN-1-2 => aggr CMTN-12 adding 
extra signal to 1 or 2, depends on average, if CMTN-1 is better than CMTN-2 or other way
then next level CMTN-1234 over CMTN-12 & CMTN-34 etc? so 1 & 2 in CMTN-1-2 are on the same side or opposite?

TSP = collecting objects/food on a plane. Spiral is a reliable algorithm but O(N^2), N - side & O(1) from # of objects, M.
Simple tracking for lines on a plane is kind of O(N) + O(M), for more complex shapes needs more levels.

Let's design it! Hold on.

Simplify further, two tiers combined:

1) temporal G/L in one channel (will control 1 Out, good addition to spiral )
2) spacial  G/L tracking L/R + temporal G/L in each one

CMTN - is spacial only? need temporal, actually it's there

0 in - 1 out, Cell initially, random search (we can't live without In technically)
1 in - 1 out, Cell, In and Out are not dependent
1 in - 1 out, INV later, stop when 1 is found
1 in - 1 out, INV + GENSS later for efficiency, slow down when 1 is found
1 in - 1 out, INV + GENSS + MEMC adding MEMC for better speed control
1 in - 2 out, INV + GENSS + MEMC + split channels, for random spiral 
1 in - 2 out, INV + GENSS + MEMC + double split channels, for pure tracking spiral
2 in - 2 out, INV + GENSS + MEMC + MEM2 for optimized tracking spiral

general rules

1) it's better to re/connect existing base elements to achive any goal, rather than change base elements
2) uniform across levels
3) min, KISS

 
(1)
                ----<----
               |         |
                --> Cell ---------> Out1                       not possible, must consume energy
                   +

(2a)

In1 -------------------------------> Out1                      random search, ineffective, unstable freq 


(2b)
                ----<------
               |           |
In1 -------------->+ Cell ---------> Out1                      random search, non-stop


(3)
                ----<------
               |           |
In1 ------------D->+ Cell ---------> Out1                      random search, smart-stop
              \--->-
               

In1 ------------->  INV ----------> Out1                       


(4a)

In1 ------------->  INV ----------> Out1
    \                           /
     \                         /                               same as (5) ineffective, unstable freq 
      -------------------------                                might work, if     In freq != INV freq

(4b)

In1 ------------->  INV ----------> Out1
    \                __/        /
     \            - /          /                               slightly diff delays for INV/GENSS, narrow freq diff
      ----------->+ GENSS -----

(5)

In1 ------------->  INV -------> MEMC -----------> Out1
    \                                          /
     \                                        /                possible but ineffective, unstable freq
      -------------------------> MEMC --> MEMC  

(6)

In1 ------------->  INV -------> MEMC -----------> Out1
    \                __/                       /
     \            - /                         /                same delays for INV/GENSS now, but wide freq diff
      ----------->+ GENSS -----> MEMC --> MEMC  

(7)

In1 ------------->  INV -------> MEMC -----------> Out1
    \                __/                                       spiral (kind of, assuming const random io)
     \            - /                                   
      ----------->+ GENSS -----> MEMC --> MEMC --> Out2

(8)

In1 ------------->  INV -------> MEMC -------------> Out1
    \                __/    \                     /
     \              /        --> MEMC --> MEMC   /             pure (tracking?!) spiral
      \           -/                           \/
       ---------->+ GENSS -----> MEMC --> MEMC /\
                            \                    \
                             --> MEMC -------------> Out2
(9)

In1 -->          --> Out1
       \ (CMTN) /                                              optimized tracking spiral
       /        \
In2 -->          --> Out2



(INV, 2nd level)  ????

    -----------<-------- 
   | FR/2               |         FR/2 generated output if there's no signal for FR/2 period
 --|----------->+ Cell1 --------- otherwise it's muted
   | FR         -                 also we can use FR/4, FR/8, etc harmonics to define longer "no signal" state
    ----------->                  hmm, not working, FR is also always triggered when FR/2 fires


(LD) long delay
         __________________________________________________
       /                                                   |
      -                                                    |
 ---> +GENSS --------> MEMC --> [... X times] --> MEMC -------->


use LD, not FR as timing is VERY important! 5 events/sec vs 5 events/ever

    -----------<-------- 
   | LD                 |         generates output if there's no signal for LD period or signal becomes aperiodic
 --|----------->+ Cell1 --------- otherwise it's muted
   |            -                 still seems unreliable?
    ----------->                  

works ok for longer "signals", like    ....111....111....111....
                                       ...1111....11......111...
                                       .....11....1.....11111...

and still better (smaller) than "naive/headon" implementation, comparing calibrated period with accumulated signals:

                                                                ---- all MEMC reset -----
    -------------------> MEMC --> [... Y times] --> MEMC --------> +GENSS ---->+         \
   /                                                                            Cell ------>
 -----> +GENSS --------> MEMC --> [... X times] --> MEMC --------------------->+         /
        -\                                                                              /
          ------                                                   --- GEN reset ------- 

and looks like for level 2 and up we need to replace (6) - (8) with


(6, symmetrical)

In1 ------> PINV --->+ GENSS -----> MEMC -----------> Out1
    \                - \____/                      /
     \               - /    \                     / 
      -------------->+ GENSS -----> MEMC --> MEMC  

what is also allowing to change out-freq in wider/any range, while INV is LD-period bound

                        ^^^^ but how reliable this CROSS-GEN in term of switching? maybe something better, like:

In1 ------> PINV --> + GENSS -----> MEMC --------------> Out1
    \             \  -                               /
     \             \/                               /
      \            /\                              /
       \          /  -                            / 
        -----------> + GENSS -----> MEMC --> MEMC  



(PINV), pure invertor, not generating

     LD                           
 -------------->+ Cell1 ---------> 
   |            -                 
    ----------->                  


(8, symmetrical)

In1 ------> PINV --> + GENSS -----> MEMC --------------> Out1
    \             \  -         \                       /
     \             \/           --> MEMC --> MEMC --- /
      \            /\                                \
       \          /  -                              / \
        -----------> + GENSS -----> MEMC --> MEMC --   \ 
                               \                        \
                                --> MEMC --------------> Out2


(CMTN, simplified & synchronized), 
no MEMC2, although MEMC "almost" ~= MEMC2 and LD is implemented with MEMC anyway
synchronized as it's not enough to trigger output after "In1 => In2" sequence, it should be timed "perfectly"
in this sense that is the real camertone, tuned to a certain frequency, also it's more natural to develop.

In1 ------> PINV --> + GENSS -----> MEMC --------------> Out1
    \             \/ -         \                       /
     \  --> PINV-- \/           --> MEMC --> MEMC --- /
      \/       LD? /\                                \
      /\          /  -                              / \
     /  -----------> + GENSS -----> MEMC --> MEMC --   \ 
    /             /            \                        \
In2 --------------              --> MEMC --------------> Out2
         LD

 ^^^ LD is being using inside PINV already

q:
0) #103 / 104 - what about mediators / plastisity? and X-level In accumulation? (ok, we track period itself)

3 types of plastisity - short / long term and STDP, all of them to change input priority levels 
when there are multiple inputs to prioritize inputs reponsible for "switching" state (starting one of GENSS in CMNT)

can/should plastisity be working inside CMNT or for Ins only?
-> likely Ins, not going to help with anything inside CMNT
may be we really should not be focusing on two Ins for now? But multi In CMTN (mixer?)
-> "it has been estimated that one neuron can receive contacts from up to 10,000 other cells." #106
can we emulate MEMC & LD with plastisity???? Why 'regular structers' such as MEMC are not observed?
-> observed #106 "Recurrent excitation is found in at least some microcircuits involved in memory processes."
however this "recurrent excitation" is not used for MEMC/LD type of structures but rather to memorize everything
in "auto-association network" by using STDP plasticity. But it doesn't mean it can not be used that way as well.


 \
 -- In1 -->          --> Out1           \ \                --> Out1
 /         \ (CMTN) /                ----- In ---> (CMTN) /
   \       /        \                 / / /               \
 -- In2 -->          --> Out2                              --> Out2
   /


anyway, using STDP plasticity we will be selecting/prioritizing Ins, triggeting either Out1 or Out2
rather Out1 as they are "tuned" (reaction to periodical signals of certain frequency) 
while Out2 is just an alternative / reaction to random Ins

actually there's a problem with self-associaiton as Out1 will always be delayed against In1 and for Out2
all Ins should be assiciated.

However, in the case of cross pollinating networks (like "auto-association network" in #106)
it should/might work, associating with Ins from other CMNTs!

interesting q though - how is placticity actually working if almost all signals should be coming to Cell
at ~ same time, otherwise it won't excite as any "excitement" from a signal won't last too long, see #somewhere
So yes, we can associate with "technically" last one to trigger Out spike but it's somewhat random anyway... hmmm

answer - see #106, Figure 21. No prioritization needed across In1 / In2 / In3 of one cell, 
but rather across "product matrix" of all interconnecting Ins

so no plasticity needed here:

                  LD             min delay
 In1----         -----           ----<-----
        \       |     \+        |         |
 In2----> In  --------> Cell1 -->+ Cell2 -----> Out1 to MEMC...MEMC --->
        /     \        -      \  -         
 In3----       \               \/          
                \              /\               
 "convergence"   \            /  -              
  smart term :)   -------------> + Cell3 -----> Out2 to MEMC...MEMC --->
                               |          |
                                ----<-----
                                 min delay

(MEMC)      min delay
           -----<-----
In        |           |
 ----------> + Cell1 --
  |       -> -        |       
  |      |            |
  |     -------------- 
  |    | |  
  |    |  ------------
  |     ---> +        | 
  ---------> + Cell2 ----------------> Out

(LD) long delay
         __________________________________________________
       /                                                   |
      -                                                    |
 ---> +GENSS --------> MEMC --> [... X times] --> MEMC -------->


try this as LD or without back-stop for MEMC chain

(GENSSS) generator start-stop slow 

                              ex: prime numbers  3 x 5 will trigger delay = 15!
     -->+ GENSS1 freq1 ---->+  
    /   -                    Cell ----->
  ----->+ GENSS2 freq2 ---->+        |
      / -                            |
      | |          stop              |
       -------------<----------------

(GENS) generator slow

                               
     -->+ GENSS1 freq1 ---->+  
    /                        Cell ----->
  ----->+ GENSS2 freq2 ---->+         
                                        

maybe not prime numbers but small delays (so we can stop it anytime) and close enough to produce long itereference,
like 100 ms and 90 ms would result in 900 ms delay. And we can add GENSS3/4/etc for more!

btw, both implementations are not reacting to any In until back-stop signal is issued, so

1...1.....  In would result in  ........................1..... Out  not   ....................1...1.....  

do we care? maybe not. More interesting q if we really need back-stop signals at all. 

                  GENS1           
                 -----           
                /     \+                   
 In ------------------> Cell1 -->+ GENSSS1 ---> Out1
              \        -      \  -         
               \               \/          
                \              /\               
                 \            /  -              
                  -------------> + GENSSS2 ---> Out2
                                   
or
                  
                 
                
 In ------------------> GENS1 -->+ GENSSS1 ---> Out1   periodical In would suppress Out1
              \               \  -         
               \               \/          
                \              /\               
                 \            /  -              
                  -------------> + GENSSS2 ---> Out2
     
                              
note: we can stop GENSSS even with a single line stop, just consuming more energy, but not triggering
q: what happens in case of "random" In? Looks like Out1/Out2 fired randomly too?
   Periodical In would suppress Out1. Absense of In would trigger Out1. But random?
   I think it's ok as EVERY new In signal would "reset" GENS1, so if second signal comes before GENS1 produces Out
   it will start count down from that point again, like:

                                   7 ticks delay
In  .............................1..  => GENS1 => .....................1..........  
In  .....................1.......1..  => GENS1 => .............1.......1..........  
In  .........................1...1..  => GENS1 => .................1..............   !!!



0) can we simplify LD and/or MEMC? with or without plasticity, we can, see above.

1) is it better in any way to use INV x 2 instead of GENSS? GENSS is very similar to INV, so it doesn't contradict to
general rule #1

2) In freq != INV/GENSS freq, see (5) example

3) even though 2 in - 2 out is the best schema for 1st level, maybe 1 in - 2 out will work ok for upper levels??

4) top levels are like music, additive harmonics

5) CMTN (implemented with MEMC2) seems rather advanced vs (8), need to simplify it or advance (8) to some "interim" improved schema?
maybe using some "timing tricks" like in INV implementation?

need to check if (8) will work for any level

(FR) before (INV/GEN) != other way around


6) still, how to grow? rules


if we want to model it we need to model lower level, not choosing CMTN as "element" as it may grow,
adjusting delays, # of MEMC elements on output side(s) or In


***************** Jun 2022 ***************** 

spatial/temporal symmetry via SYM elements (internally using MNAND and/or MNOR for all inputs 000 or 111?)
if lasted a few cycles only (avoid randomness insanity)

DO NOT train, just self-train for simplicity (IO=GF). 
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
  all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
  link (N ins, M outs), delayed out for 1 timeslice, can randomly grow/split with freq
  cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow
  reaction to signal and delayed signal - basis for pattern recognition

1 in - 1 out  = random strategy is the best, 0->r
1 in - 2 outs = outward spiral is the best, 0->s, -1->r, 1->"downward spiral"/tracking (rough)
2 in - 2 outs = "outward spiral" / "downward spiral" (smooth) shape tracking, no internal model, 0->s, -1->r, 1->t

2 in - 2 outs (stereoscopic vision) is just optimized version of 1 in - 2 outs (better entering phase).
Is that true for all levels or only for the bottom?
btw, "downward spiral" has sine wave as 1st harmonic

[1st level]

different periods ("density") and / or phase shift ("shapes") can be handled with tracking logic:

actually with combo of 2 elements:

2 ins - 1 out
left  gain -> right gain = excite,  sending signals more frequently / in terms of deviation - positive, higher probability
left  loss -> right loss = excite,  sending signals more frequently
right gain -> left  gain = inhibit, sending signals less frequently / in terms of deviation - negative, lower probability
right loss -> left  loss = inhibit, sending signals less frequently

frequency is const / fixed at every level, different between levels


implementation 1          delay1
                         ________       freq1
                       +!        |
                      -> Cell2-1 ---> Out1
                     /
                    /     delay2
                   /     ________       freq2
         +        /    +!        |
In1 ----> Cell1-1 -----> Cell2-2 ---> Out2
    \   /+        
     \ /          
 delay/           
     / \ +                              freq2
In2 ----> Cell1-2 -----> Cell3-1 ---> Out1
         +        \    +!________|
                   \      delay2
                    \                   freq1
                     --> Cell3-2 ---> Out2
                       +!________|
                          delay1

(comparator)            (generator)
(accumulator) before that?


how to stop concurrent in? or switch outputs?
how to change freq?
what is memory? delay or fixed state? maybe both. Can delay replace fixed state? yes,
I think simple reversed (FD) below would do the trick! but only working on high freq, min delay.

First   1 on + line would initiate continuous generation and
another 1 on - line would stop it no matter when it's sent as period is min we should break the evil loop!!!

      min delay
     -----<-----        and then we feed it into gateway so we can pass/stop any signals for the period of time we need!!!
    |           |                                                      btw, subsequent 1 on + or - does nothing
 ------> +Cell1 ----------------> +Cell2 ---> gated out
 ------> -                ------> +
control impulse           controlled wave

(MRFD)                    (GATE)
minimal
reversed
frequency
divider

problem with this schema is inefficiency, to keep the gate open for infrequent signal we need high freq control impulse.
but first - draw end-to-end with 2nd level explained.
need asymmetry / trigger, one signal circulating in a loop creates asymmetry?
                   
          level 1, lowest, 1 signal to passs                    
In1 ---->+Cell1-1 ---> Out1
         +       /      
          \_____/ 
          _____/\                     
         /       \              
        /+        \ 
In2 ---->+Cell1-2 ---> Out2
          level 1


circulation is the state:

(TRIG)

            min delay
          ------<-----
In       |            |  level 1
 ----------> +Cell1 -----------------> Out
  |       -> -        |       
  |      |            |
  |     -------------- 
  |    | |  
  |    |  ------------
  |     ---> +        |  level 2, two signals needed
  ---------> +Cell1 --

This is still a trigger, not divider. But with some changes:


(MEMC)
(MEMCircular)

            min delay
          ------<-----
In       |            |  level 1
 ----------> +Cell1 ---
  |       -> -        |       
  |      |            |
  |     -------------- 
  |    | |  
  |    |  ------------
  |     ---> +        |  level 2, two signals needed
  ---------> +Cell1 -----------------> Out

should work?!

            min delay
          ------<-----
In       |            |  level 2, two signals needed
 ----------> +Cell1 -----> +Cell1 ---> Out
  \          -             +      /
   \         \____________/______/
    \____________________/


can we implement schema above without fixed state(s)?
another q - how to implement comparator for longer periods? Or we rather need (accumulator) before that?
so we react to fast changes for level 1 and long ones for level 2. Like (ACC) below?
still not sure how to implement 2nd level comparator? (ACC) should do it. But for short periods only.
Need "universal delay" otherwise. And for comparator as well.

maybe we don't really need a long delay for comparator as both signals L and R will likely appear/disappear
at the same/close time. So need it for ACC only.

It's important to react to both types of IO - gain AND loss, so ACC should produce 1 out in response to gain 
and 1 in response to loss (on level 1 we need state machine again to avoid false events? maybe not as
gain/gain or loss/loss will produce the same reaction)

What criteria to allow comparing phases? Like L/R (first L) or R/L. "long run" is too vague.
no criteria. It could be first/last/or SAME time. And the longer the "averaging period" and closer L and R inputs
the more likely we get the SAME.

reaction to gain/loss, (XOR):

   delay 1 cycle, level 1
 --->---->+         
     \ \   Cell---- 
      --->+        \    
      \ \           -> +Cell---->
       \ ->+        -> -      
        \   Cell---/
         ->+   
              level 2 (both Ins only)        

can we implement it with small delays? do we really need precise delays/timing or just simple "concept before"?

(MEMC2, two Ins) implemented with GENSS (below)

.11...      min delay
          ------<-----
In1      |            |  level 1
 ----------> +Cell1 ---
          -> -        |       
         |            |
        -------------- 
...1.1 | |  
       |  ------------
In2     ---> +        |  level 2, two signals needed
  ---------> +Cell1 -----------------> Out  ...1...

In1
 ---------> GENSS ----
          /           |
        -------------- 
       | |  
       |  ------------
In2     ---> +        |  level 2, two signals needed
  ---------> +Cell1 -----------------> Out 



             (GENSS) (Generator with Start/Stop)

           min delay
          -----<----- 
         |           |  
    ------->+ Cell1 --------- 
    ------->-




would react to In1 => In2, not the other way around
but with  "concept before" we're loosing period - essenial UID of event?
generally period remains the same but may vary sometimes (when subject moves) and "more changes => more reaction"

so:
1) "concept before" is essential and affects reaction (yes/no) & easy to implement
2) period change would only affect strength of reaction  (1..10) & tricky (delay issue)

XOR + MEMC2 = how? table it as
technically MEMC2 is already reacting to gain In1 -> gain In2 temporal sequence

Reaction to loss In1 -> loss In2 sequence: full In inversion + MEMC2

              (GEN)

11111..     min delay
          -----<-----           INV
         |           |  
          ->+ Cell1 --------- 
                             \ +
                                Cell2 --------> Out .....11
      In                     / - 
      ----------------------- 

issue with long out delays (om "implementation 1" pic) can be solved with array:

GEN --> MEMC --> MEMC --> MEMC --> MEMC -->
    \        \        \        \        \         
     -->      -->      -->      -->      -->      
      Fr      Fr/2     Fr/4     Fr/8     Fr/16
      base
      heartbeat

producing diff freq. But do we need fractionals? What happens if we mix Fr/2 + Fr/4? And how do we mix it?



"Implementation II", Level 1 - N, requirements: uniform across levels & min (not min, can be simplified across levels, MIX)


                               Fr/N from GENARRAY
  inverted In S/S -------        \
                  ----- |         \
In1                    ||           +
   ------->1 MEMC2 ---> +GENSS ---> +Cell --------------> Fr/N
   \  ---->2      \   / -                 \
    \/             \ /               GATE  \
    /\              /                       ---> MEMC --> Fr/(N*2)   upper level is increasing or decreasing 
   /  \            / \  -                                            turn's radius by?  N*2 -> closer to N?
   ----\-->1 MEMC2 ---> +GENSS ..... reversed out                    equal probabilities, see below MIX
In2     -->2           ||
                   -----|
   inverted In S/S ------

For level #N

In1 ---> MEMC ---> MEMC ---> ...[N times]... ---> MEMC ---> In1 ---> above
In2 ---> MEMC ---> MEMC ---> ...[N times]... ---> MEMC ---> In2 ---> above


(MIX), can be simplified, see Oct 2022

1..1..1..1..1..1..1..1..1.                   1.....1.....1.....1.....1...
  Fr                               Fr/2
 ---> MEMC --------------------------> mix   1.1...1.....1.1...1.....1.1.
           \              +      / Fr/4
            ---> MEMC --> Cell --            ..1...........1...........1. 
                          + 
                         /  small delay
                        /   to avoid synphase substraction (may not be a problem if amplitude can be doubled)
                       /                                    and this helps to make a wider turn
                     gate signal             2.....1.....2.....1.....2...

normally for uplevel control we gradually adjust freq up --> down --> up --> down...., to how to adjust mixture?
up and down = these are 2 diff controls, so UpIn to increase freq, DownIn - decrease.
Problem - Gate Cell is not very fit for the role?

No "simple" delays (not working for long peiods, see above), but simple freq addition 1/2 + 1/4 + 1/8 = 7/8 ~= 8/8 !!
Just 3 down harmonics give us huge turn variation. How to add? 
All signal should come form GENARRAY, small variable phase shift/delay is still needed???, kind of DAC

1.1.1.1.1.1.1.1.1           1.1.1.1.1.1.1.1.1.1          1.1.1.1.1.1.1.1.1.1.
1...1...1...1...1           .1...1...1...1...1.          .1...1...1...1...1.. 
1.......1.......1           ..1.......1.......1          ...1.......1.......1

issue ==> can't implement delay for long periods, see above

1..1..1..1..1..1..1..1..1   1..1..1..1..1..1..1..1..1..1   delay = heartbeat * 0
1.....1.....1.....1.....1   .1.....1.....1.....1.....1..   delay = heartbeat * 1
1...........1...........1   ..1...........1...........1.   delay = heartbeat * 2
________________________________________________________
1..1..1..1..1..1..1..1..1   1111..11.1..1111..11.1..1111 =  7/12 = 1/3 + 1/6 + 1/12

actually it's not a problem for periods > 3 min heartbeats if we add 3 harmonics we can shift this way, min delay.
for more harmonics needs longer base period 
=> just don't change divider /2, otherwise there may be some overlap... /3 /5, etc not good
actually /3, /9, /27 all lower harmonics are inclusive if not shifted

NOTE 1: Fr/N from GENARRAY seems like optimization & better not to be done due to reliability reasons
NOTE 2: think of thopology - inverted In split in left/right hemispheres or reversed out (most likely) or both?
NOTE 3: for implementation - in every cell (?) don't forget after triggering delay/sleep, "non reacton time", sAHP, 
			     slow after-hyperpolarizing currents after each spike
                             this is not "low level" delay (for limited/short periods) but rather /2, /4?
                             this delay would define In/analysis filter freq??
NOTE 4: q - how to control freq change? One signal - start going up, another - down 
	by changing delay = heartbeat * 2/1/0??
NOTE 5: engramms? why we need it? for freq change control somehow? growing in general?
	complex pattern recognition - like music tune recognition, many cells involved, engramms?  #100
                        reproduction, In filter freq => Out mixed tunes/patterns

NOTE  : so maybe there's no control from top to bottom, signals just summarized from all levels?


and same for inverted In's (loss instead of gain)

Can we use internal out from MEMC2 instead of GENSS? no, even inversed

simplify? reversed/inverted

test/check level #N In reduction if valid

test for overlapping Ins: won't mute it wrongfully?

....11111111111.........
...........111111111....




so (ACC) is not usable for that purpose, even for gain!

Not a delay, but rather LTM (long term memory)

see #99, engramms

recording: and similar reading at any given moment later

     |         |         |
    (TRIG1)   (TRIG2)   (TRIG3)
       \         \         \
In ---------------------------------->
    +|   \     |   \     |   \
    GATE1-    GATE2-    GATE3-
    +|         |         |
   ->delay -> delay -> delay --
  |                            |
   ----------<-----------------


simple freq divider (for fixed period and deducted from higher harmonics), lower freqs are passed through:

(FD)
        delay1         
     -----------
    |           |         
     --> -Cell1 ---> 
 ------> +


or below, see (BB) for high freq only:

f1 - - - - -                -   -   - f1/2    
 Out2 --------> Cell2 ---->                   
                level 1


***************** Apr 2022 ***************** 

spatial/temporal symmetry via SYM elements (internally using MNAND and/or MNOR for all inputs 000 or 111?)
if lasted a few cycles only (avoid randomness insanity)

DO NOT train, just self-train for simplicity (IO=GF). 
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
  all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
  link (N ins, M outs), delayed out for 1 timeslice, can randomly grow/split with freq
  cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow
  reaction to signal and delayed signal - basis for pattern recognition

1 in - 1 out  = random strategy is the best, 0->r
1 in - 2 outs = outward spiral is the best, 0->s, -1->r, 1->"downward spiral"/tracking (rough)
2 in - 2 outs = "outward spiral" / "downward spiral" (smooth) shape tracking, no internal model, 0->s, -1->r, 1->t

2 in - 2 outs (stereoscopic vision) is just optimized version of 1 in - 2 outs (better entering phase).
Is that true for all levels or only for the bottom?
btw, "downward spiral" has sine wave as 1st harmonic

[1st level]

different periods ("density") and / or phase shift ("shapes") can be handled with tracking logic:

actually with combo of 2 elements:

2 ins - 1 out
left  gain -> right gain = excite, sending signals more frequently / in terms of deviation - positive, higher probability
left  loss -> right loss = excite, sending signals more frequently
right gain -> left  gain = inhibit, sending signals less frequently / in terms of deviation - negative, lower probability
right loss -> left  loss = inhibit, sending signals less frequently

frequency is const / fixed at every level, different between levels


implementation:        delay increasing (transient process) and/or level decreasing
                       ________
         +           +!        |
In1 ----> Cell1-1 ---> Cell2-1 ---> Out1
    \   /+           - \__  __/
     \ /                  \/
 delay/                 __/\__      
     / \ +           - /      \       
In2 ----> Cell1-2 ---> Cell2-2 ---> Out2
         +           +!________|
                       delay increasing (transient process)


Level 1 technical implementation - no need in state machine? KISS 
and endless (albeit slow when not active) generation at every out is not needed, only the model's artifact? 
as too much energy consumption for nothing.  but heartbeat?

How is level 2 implemented with those elements/topology?
q1: how to enlarge turns? as adjusting delay may work well for level >=2 but for 1 we have rendering/model issues.
Still need to consider level 1 physical limitations as this was a foundation for building up - less often pulses (delay)
wouldn't result in a bigger turns (even with off-centered jet -> and a bit of spinning). So ratio (read: probability)
of left/right pulsation is more important?

start with simple LRLRLRLRLRLR generator, then adjust raitio

(RR)

                        weak       strong signals contour
         +                +    
In1 ----> Cell1-1 --->--->  Cell2-1 ---> Out1
    \   /+            \  /- \__  __/
delay\ /     adj level \/      \/   delay fixed (maybe adjusted from another level??)
delay /          level /\    __/\__ delay
     / \ +            /  \- /      \       
In2 ----> Cell1-2 --->--->  Cell2-2 ---> Out2
         +                +         
                     
delay won't help to make left/right turns actually, just slow it down
not delay -> probability? but if signal is not generated (probability = 0) this whole LRLRLR chain will break.
maybe we need to adjust output level/power instead?

still: not sure if 1 higher level wave out of ~10 (example) is enough, should either be steady higher level or more frequent:

implemented above:

          L turn
          -
L - - - -   - - - - - 


R  - - - - - - - - - 


needed:

          L turn
          - - - - - - 
L - - - - 


R  - - - - - - - - - 
          note: no right turn atm, othewise this is "speed up", not turn!
  

or

              L turn
L -   -   -   - - - - - - - - 
 

R  -   -   -   -   -   -   -   -


Lets start with "go forward"...

(AA)

 delay1                ----> Out2
 ------               /
|     |              /
 --> Cell1 ---> Out1 \
                      \
heartbeat              ----> Out3
                       delay2

delay1 and delay2 could be coordinated, but technically should work with any values
normally delay2 < delay1, optimal delay2 = delay1 / 2


and then add "turn"??? increase freq at one out, either Out2 or Out3, but not both:

(1) increase freq

         delay=period/2
          <------- 
         |        |
 Out2 -----> Cell2 ---->
 Freq2-1           Freq2-2 = Freq2-1 * 2
 Level2-1         Level2-2 = Level2-1

alternatives? how to increase level?

(2) increase level

         delay=period
          <------- 
         |        |
 Out2 -----> Cell2 ---->
 Freq2-1           Freq2-2 = Freq2-1
 Level2-1         Level2-2 = Level2-1 * 2 if we assume that higher In triggers higher Out, what is not certain

so (1) seems more feasible? in fact they are invariant when delay=~period (close), and resulting impact will be the same
for any delay:period ratio, but practically delay < period (should be)

(3) forward delay makes more sense (no overlapping waves)

(BB)
         delay                                           delay
          ---->                                          ----> 
         |     |                                        |     |
 Out2 --------> Cell2 ---->               ----> Out2 --------> Cell2 ---->

f1 -   -   -                - - - - - f1*2      - - - - -                 ---------- f1*4

same effect - freq reduction:

f1 - - - - -                -   -   - f1/2      -   -   -                 -        - f1/4  larger turns
 Out2 --------> Cell2 ---->                   ----> Out2 --------> Cell2 ---->


and freq reduction is easier way to adjust freq to do turns as changing "delay" doesn't impact it, 
but changing "triggering level" does! So instead of "multi-tiering" keep one cell but adjustable

also freq multiplication has its limit (continuous "const level" as pitch duration > 0)
but there's no limit for divison

f1 - - - - -                -   -   - f1/2    
 Out2 --------> Cell2 ---->                   
                level 1

f1 - - - - -                -     -   f1/3
 Out2 --------> Cell2 ---->                   
                level 2 > level 1

conforming division schema (no signal "accumulation/retention" needed)

f1 - - - - -                -     -   f1/3
     /---->delay0---->In1.
 ---> ---->delay1---->In2. Cell2 ---->
     \---->delay2---->In3.        btw, "triggering level" here = the same as at level 2 above!

delay0 < delay1 < delay2

(ACC) accumulator

delay should be = period * NN for this division to work

(XX)
            f1 - - - - -                
     /--------------->In1+
 ---> ---->delay1---->In2+ Cell1 ---->
shifted      f1 - - - - -               ........... nothing, out of phase
shifted more f1  - - - - -                - - - - - same f1, but delayed / not divided!

problem - delayed / not divided!

ACTUALLY it seems that level (even though it may or may not externally adjustable) is playing main role
in freq dividers implementation, looking at 
https://qbi.uq.edu.au/brain-basics/brain/brain-physiology/action-potentials-and-synapses

f1 - - - - -                - - - - - f1
 Out --------> Cell ---->                   
               level 1

f1 - - - - -                -   -   - f1/2    
 Out --------> Cell ---->                   
               level 2

f1 - - - - -                - - - - - f1
 Out -------->+ Cell2 ---->                   
 Out -------->+ level 2
f1 - - - - -                

f1 - - - - -                ......... 0
 Out -------->+ Cell2 ---->                   
 Out -------->+ level 2
f1  - - - - - phase shift

AND STILL problem - won't work for long periods as short impulses won't accumulate
same solutions as below?
"but may be this schema works on a few period "wavelength" only?"

similar to (XX) but with "reset":

In1 ----->+ Cell1 -------->
       \ /+       \
        \          \ -
       / ----------->+ Cell2 --
      /                       |
      --------<----------<-----
          delay = period

might work, but too complicated and unstable, can fail easily if In period would change a bit

so - dividing signals freq is hard, but generating with diff freq is easy! see (YY) below


level does still depend on freq, one level can't work for all freq divisions

drawback - division by whole, 1/2, 1/3, 1/4, 1/5... resulting freq 
is it drawback? May be enough? Alternatively use NOT (inhibit) for smaller changes, like:

          - - - - - - -        -     -     -          - -   - -  
 delay1               
 ------               
|     |                  Freq 1/3                     Freq (1 - 1/3)
 --> Cell1 ------------> Cell2 ----> In1- Cell3 ----> Out3
     Level1\             Level3      In2+ Level1
            \                       / 
             -----------------------


why not (below) - because direct delay/level adj is questionable? (out of paradigm)
so combine it all into (CC"), below.


(YY)

            delay1
          /  <------- 
         /  |        |
delay   /    --> Cell1 ---->
    -->/
adj    \    
        \    
         \   --> Cell2 ---->        
          \ |        |
           \ <------- 
             delay2

starting generation is easy

        delay1         
       ---------
Start |         |         
 ------>+ Cell1 ---> 
-              -  -  -  -  -  -

but stopping is not:

        delay1         
       ---------
Start |         |         
 ------>+ Cell1 ---> 
 ------>-
 Stop 
- - - -        -  -  -  -  -  -

need higher freq signal for > 1 period or more


how to integrate with (AA) into (CC) ?

(AA)


 delay1                ----> Out2
 ------               /
|     |              /
 --> Cell1 ---> Out1 \
                      \
heartbeat              ----> Out3
                       delay2


(CC)
                       delay increasing (transient process)
                       ________
         +           +!        |
In1 ----> Cell1-1 ---> Cell2-1 ---> Out1
    \   /+           - \__  __/
     \ /                  \/                      problem here - can't enlarge turns, only (BB) can do that!
 delay/                 __/\__      
     / \ +           - /      \       
In2 ----> Cell1-2 ---> Cell2-2 ---> Out2
         +           +!________|
                       delay increasing (transient process)

it's still somewhat questionable - how this is going to work for long periods? Sending '-' for the whole period?
or periods should be in sync, like on (RR) above?
but may be this schema works on a few period "wavelength" only? If longer periods needed for output - just divide!


(CC")
                       delay increasing (transient process)
                       ________
         +           +!        |          fast
In1 ----> Cell1-1 ---> Cell2-1 ---> Out1 ------------->
    \   /+           - \__  __/          \   /
     \ /                  \/              \ /level2 (slow)      
 delay/                 __/\__             /
     / \ +           - /      \           / \level2 (slow)
In2 ----> Cell1-2 ---> Cell2-2 ---> Out2 ------------->
         +           +!________|          fast
                       delay increasing (transient process)


One question - is it minimal solution?

Another question - how to change freq / turn radius?


[Next level(s)]

symmetry level 1 - line (straight, curved)
symmetry level 2 - group of lines - lattice
symmetry level 3 - group of lattices

Leaving (turning away from) level 1 DELIBERATELY, even though we can still track it and there is enough food there

how now? self reducing deviation to 0, same transient process as above??
think in terms of probablility or delay/freq?


***************** Feb 2022 ***************** 

spatial/temporal symmetry via SYM elements (internally using MNAND and/or MNOR for all inputs 000 or 111)
if lasted a few cycles only (avoid randomness insanity)

DO NOT train, just self-train for simplicity (IO=GF). 
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
  all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
  link (N ins, M outs), delayed out for 1 timeslice, can randomly grow/split with freq
  cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow
  reaction to signal and delayed signal - basis for pattern recognition

1 in - 1 out  = random strategy is the best, 0->r
1 in - 2 outs = outward spiral is the best, 0->s, -1->r, 1->"downward spiral"/tracking (rough)
2 in - 2 outs = "outward spiral" / "downward spiral" (smooth) shape tracking, no internal model, 0->s, -1->r, 1->t

2 in - 2 outs (stereoscopic vision) is just optimized version of 1 in - 2 outs (better entering phase).
Is that true for all levels or only for the bottom?
btw, "downward spiral" has sine wave as 1st harmonic

[1st level]

different periods ("density") and / or phase shift ("shapes") can be handled with tracking logic:

actually with combo of 2 elements:

2 ins - 1 out
left  gain -> right gain = excite, sending signals more frequently / in terms of deviation - positive, higher probability
left  loss -> right loss = excite, sending signals more frequently
right gain -> left  gain = inhibit, sending signals less frequently / in terms of deviation - negative, lower probability
right loss -> left  loss = inhibit, sending signals less frequently

frequency is const / fixed at every level, different between levels

(a)

In1 ----> Cell1-1 ---> Out1
    \   /  +| |-
     \ /    |  ----------------
      /      ----------------  |     freq1
     / \                     | |
In2 ----> Cell1-2 ---> Out2  | |
           +| |-             | |
            |  ------\       | |
In1 ----> Cell2-1 -----------  |
    \   /             \        |     freq2 << freq1
     \ /               \       |
      /            ----        |
     / \         /             |
In2 ----> Cell2-2 -------------

now need to factor in +/- GF, how? GF is actually "In" as you recall, main In function - feed / good / bad.
IO L/R to every cell and GF directly cell to cell (looks like it) or other way around - GF to every cell and IO L/R cell to cell?
and GF +/- accounts for 2 connections, one inhibit one excite??

How this might work for In3? As a combo - use In1/In2 at level 1 and In1/In3 at level 2 for example.
at level 1 difference In1/In2 vs In1/In3 can be significant if it's more distant, but at level 2 it will level off.

Do we really need:
"3) capturing - back to tracking 1st level when found, controlled by what? "founder" to distinguish this track from
another one by period violations? should get back (reduce deviation) quickly / immediately"
maybe not - just fine tuned timing and same "zero/reaction" level between tiers 1 & 2?

or maybe this topology? how is it better?

(b)

In1 ----> Cell1-1 ---> Out1
    \   /   || |-
     \ /    ||  ---------------
      /sync+||-sync            |     freq1
     / \    ||                 |
In2 ----> Cell1-2 ---> Out2    |
              + \              |
                 \             |
In1 ----> Cell2-1-             |
    \   /   ||                 |     freq2 << freq1
     \ /    ||                 |
      /sync+||-sync            |
     / \    ||                 |
In2 ----> Cell2-2 -------------


Why not invertors? maybe duplication / reliablity? so either sync/invert (c) or sync/reconcile (b) or no sync (a)?

Looks like sync/reconcile is the best and actually no need to reconcile as could help react faster? because sync
path is symmetrical both ways, but "distribution path" (a) may or may not be.

faster is good but what about false operations? Cell1-1 triggered => sync Cell1-2 inverted => Cell1-2 triggered?
Seems always in-phase so Cell1-2 is producing the same output when triggered and inverted.


(c)

In1 ----> Cell1-1 ---> Out1
        /   || |-
       /    ||  ---------------
      /sync+||-sync/invert     |     freq1
     /invert||                 |
In2 /     Cell1-2 ---> Out2    |
              + \              |
                 \             |
In1 ----> Cell2-1-             |
        /   ||                 |     freq2 << freq1
       /    ||                 |
      /sync+||-sync/invert     |
     /invert||                 |
In2 /     Cell2-2 -------------



(d) out of curiousity - how is that better so it makes to all level? Faster.

try implement it now 

In1 ----> Cell1-1 ---> Out1
    \   /   || 
     \ /    || 
      /sync+||-sync            
     / \    ||                  
In2 ----> Cell1-2 ---> Out2

soma - works as summator of dendritic inputs, emitting signal at cut-off level (signal either + or - exciting
or inhibiting, more excitation!), technically 'AND' element, producing oscillations at Out1 via positive self-feedback
and at the same time inhibiting oscillations at Cell1-2 / Out2???
       ____________
      !            |
In1 ----> Cell1-1 ---> Out1
    \   /\       /inhib 
     \ /  \_______
      /   _____/  \inhib             
     / \ /         \            
In2 ----> Cell1-2 ---> Out2
      !____________|

^^^^ not going to work (can't stop generated signals)

smart generator:

In4 (backfeed)   + __________
                  !          |
In1 (normal) --->+ \         |
                    \        |
In2 (power)  --->+  / Cell---------->
  const offset     /
In3 (stop)   --->-

Issue - stop should be long enough to suppress it during the whole backfeed cycle to interrupt generation

Solution: wave generation at the beginning is a transient process so level and/or freq should be higher!
This will override and inhibit/dampen concurrent other Out! I hope :-)

Issue #2 - how exactlly does it work? ;-)  can't create generator witout periodical master signal at In2
and in that case this will be just freq divider, not reacting to In1 at all?!
unless trip level is very low, so no master signal is needed, no In2:

In4 (backfeed)   + __delay___
                  !          |
In1 (normal) --->+ \         |
                    \        |
                    / Cell---------->
                   /
In3 (stop)   --->-


And finally:

(CC)
                       delay increasing (transient process)
                       ________
         +           +!        |
In1 ----> Cell1-1 ---> Cell2-1 ---> Out1
    \   /+           - \__  __/
     \ /                  \/
 delay/                 __/\__      
     / \ +           - /      \       
In2 ----> Cell1-2 ---> Cell2-2 ---> Out2
         +           +!________|
                       delay increasing (transient process)


https://qbi.uq.edu.au/brain-basics/brain/brain-physiology/action-potentials-and-synapses
https://lenta.ru/news/2022/02/22/neurons/
https://neuraldevelopment.biomedcentral.com/articles/10.1186/1749-8104-3-9
https://www.sciencedirect.com/science/article/pii/S0896627318309449
https://www.eneuro.org/content/9/2/ENEURO.0469-21.2022
https://journals.physiology.org/doi/full/10.1152/jn.00843.2014

Alternative solution:
if we're not going to generate output forver but just for a little while, we don't really need a stop signal!
so 1 in => 10 outs, that's it!


In4 (backfeed)   + __________ ???? needed
                  !          |
In1 (normal) --->+ \         |
                    \        |
In2 (power)  --->+  / Cell----------> In x 10 outs :) like damped wave
  const offset     /

Issue - is it suitable for all conditions? or for small periods only? or we can adjust 1x10 ratio? how do we stop??
Issue - it maybe easier to generate 1 out signal or endless (and react to stop), fixed # of waves may be tricky

So let's not do this ^^^^^^^^^^^^^^^^^^ but "smart generator" above


back-propagating action potentials, these signals depolarize the dendritic arbor and provide a crucial component 
toward synapse modulation and long-term potentiation/depression (changing average signal spike level, short memory?)

#95 however long-term memory (on strong GF) rather formed with new/changed spatial connections, not LTE.

periodical inhibition would allow react to 2 closely timed inputs and react to L->R or R->L sequence
but would only generate 1 spike, need more?


[Next level(s)]

symmetry level 1 - line (straight, curved)
symmetry level 2 - group of lines - lattice
symmetry level 3 - group of lattices

Leaving (turning away from) level 1 DELIBERATELY, even though we can still track it and there is enough food there

how now? self reducing deviation to 0

***************** Oct 2021 ***************** 

spatial/temporal symmetry via SYM elements (internally using MNAND and/or MNOR for all inputs 000 or 111)
if lasted a few cycles only (avoid randomness insanity)

DO NOT train, just self-train for simplicity (IO=GF). 
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
  all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
  link (N ins, M outs), delayed out for 1 timeslice, can randomly grow/split with freq
  cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow
  reaction to signal and delayed signal - basis for pattern recognition

1 in - 1 out  = random strategy is the best, 0->r
1 in - 2 outs = outward spiral is the best, 0->s, -1->r, 1->"downward spiral"/tracking (rough)
2 in - 2 outs = "outward spiral" / "downward spiral" (smooth) shape tracking, no internal model, 0->s, -1->r, 1->t

2 in - 2 outs (stereoscopic vision) is just optimized version of 1 in - 2 outs (better entering phase).
Is that true for all levels or only for the bottom?
btw, "downward spiral" has sine wave as 1st harmonic

[1st level]

different periods ("density") and / or phase shift ("shapes") can be handled with tracking logic:
  left  gain -> right gain = reverse if left  thrust
  left  loss -> right loss = reverse if left  thrust
  right gain -> left  gain = reverse if right thrust
  right loss -> left  loss = reverse if right thrust

==> co-directional arrows seems to be working great. Only watch for Gain/Loss per channel and once flipped 
==> in the same direction check if action should be reversed. 

For tracking co-directional arrows seems to be working great, but needs implementation tweaks, 3 periods and states:
gain/loss, gain/loss limited, wait, turn (see below)

[Next level(s)]

symmetry level 1 - line (straight, curved)
symmetry level 2 - group of lines - lattice
symmetry level 3 - group of lattices

Leaving (turning away from) level 1 DELIBERATELY, even though we can still track it and there is enough food there
We're not leaving 100% but increasing amplitude to one side and then other when Level 2 is affecting Level 1 wait period

Why it's more efficient vs simple Level 1 tracking - potentially can consume more and more efficient in a long run
as we can find "good spots" in a sparse space if they are recurrent / grouped. But only if our period or
rather period / deviation ("wait time") ratio is allowing to spot / reach / find them.

There may be 2 and more level-2 cells, 2 and more level-3 controlling level 1 and 2.
How to combine them optimally? and how to tune period / deviation ratios to begin with? or ONLY wait time?

Level difference = period difference, thus period is fixed for the level, so
may be create a few competing level-2 cells with same period, but different "wait time" and see which one succeeds?
how they can compete if there's only one "steering wheel" - meaning one level 1 cell with left/right thrust?
"as if" internal model? build it and run with various cell combinations?

ok, "kiss" similar to class-D controlling signal from level 2 opens "turning gate" so we turn more the longer it's open
when upper thrust is reversed we gradually reduce the turning radius the longer it's reversed

second level - period of the same global IO or maybe mix level 1 turns????
do we need to catch/stick to "another food line" when switching as from second level perspective - we should not
continue to increase 1st level period?! hm, how to do that - maybe second level control, like:
IO - 1st level turns, actions - 1st level turn delays? IO - LRLRLR -> LLRRLLRRLLRR? report two events, like 
L wait -> L turn -> R wait -> R turn? maybe, maybe not.

There seems to be 3 different routines working together:
1) tracking, follow 1st level path, controlled by IO
2) tracking 2nd / higher level of longer period IO to control 1st one by pushing it off the path periodically
   and back slowly (when running out of resources, level 2 control - reversed) 
3) capturing - back to tracking 1st level when found, controlled by what? "founder" to distinguish this track from
another one by period violations? should get back (reduce deviation) quickly / immediately

There's no such thing as go L/R, always - series of impulses/actions going both ways with diff ratio:

      |
******|
 *****|*
  ****|**
   ***|***
    **|****
     *|*****
      |******

           |
* * * * * *|
  * * * * *|*
    * * * *|* *
      * * *|* * *
        * *|* * * *
          *|* * * * *
           |* * * * * *

         ------ L
        /
Gen ----
        \
         ------ R

Base Gen is always On. This is more straightforward and easy to implement than two out-generators:
but can we switch L <-> R quickly with that "valve"?

And what about ref #-1  more freq => more movement/action?
so how to sync / coordinate left-right turns:

Gen1 ---------- L
 |
Freq Adj   either both up / both down (more amplitude) or higher freq to 1, lower freq to 2 (turn L), etc
 |
Gen2 ---------- R

or (similar to one above, but different valve)

        ---------- L
        |
Gen -- Freq Divider / Adj   either both up / both down (more amplitude) or higher freq to 1, lower freq to 2 (turn L), etc
        |
        ---------- R

TODO: redesign PeriodTracker to conform the model above and simplify connections for many cells


and again - synchrony (universal GF, -1, 0, +1) / gravity / probability / choice - reflections
? many connected downlinks on a single In - combined momentary capacity (OR) -> pwm - same amplitude, diff signal length



***************** Jul 2021 ***************** 

spatial/temporal symmetry via SYM elements (internally using MNAND and/or MNOR for all inputs 000 or 111)
if lasted a few cycles only (avoid randomness insanity)

DO NOT train, just self-train for simplicity (IO=GF). 
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
  all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
  link (N ins, M outs), delayed out for 1 timeslice, can randomly grow/split with freq
  cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow
  reaction to signal and delayed signal - basis for pattern recognition

1 in - 1 out  = random strategy is the best, 0->r
1 in - 2 outs = outward spiral is the best, 0->s
2 in - 2 outs = "outward spiral" / "downward spiral", smooth shape tracking, no internal model, 0->s, 1->t 

2 in - 2 outs (stereoscopic vision) is just optimized version of 1 in - 2 outs (better entering phase).
Is that true for all levels or only for the bottom?

[1st level]

different periods ("density") and / or phase shift ("shapes") can be handled with tracking logic:
  left  gain -> right gain = reverse if left  thrust
  left  loss -> right loss = reverse if left  thrust
  right gain -> left  gain = reverse if right thrust
  right loss -> left  loss = reverse if right thrust

==> co-directional arrows seems to be working great. Only watch for Gain/Loss per channel and once flipped 
==> in the same direction check if action should be reversed. 

For tracking co-directional arrows seems to be working great, but need 3 periods:

a) period A, tracking gain/loss per side-channel L/R
b) period B, once found gain/loss on one side wait for this period to see co-directional gain/loss on the other side
and if not found another gain/loss revert to (a), do not persist gain/loss state across another period B

If both triggered at the same time - flip (or random side maybe)
q: always wait for the full period B or can make decision right away, when find another gain/loss? maybe, try both
if we wait our turns will be more periodical, less random

c) period C, once made a decision based on (b) and turn or no turn, continue for period C no matter what (no reactions)
A < B = C ?

state machine: collect enough data to compare -> wait for 1st flip -> wait for 2nd flip -> wait for turn/no turn ends
note: "collect enough data to compare" should be smart - after reset we need at least 2 cycles, should not assume
we start with 000 or 111, otherwise may flip for wrong reason

design pattern https://gameprogrammingpatterns.com/state.html



[Next level(s)]

symmetry level 1 - line (straight, curved)
symmetry level 2 - group of lines - lattice
symmetry level 3 - group of lattices

Leaving (turning away from) level 1 DELIBERATELY, even though we can still track it and there is enough food there

so this departure is forceful, one time thing, like reached limit when no changes -> turning (2nd level supercedes 1st)
or gradual - second level pushing 1st aside all the time, so eventually 1st level looses tracking and then 2nd get
it back on track? aside = affecting 1st level "devation" - turning more to the left or right?


and again - synchrony (universal GF) / gravity / probability / choice - reflections
? many connected downlinks on a single In - combined momentary capacity (OR) -> pwm - same amplitude, diff signal length


***************** May 2021 ***************** 

spatial/temporal symmetry via SYM elements (internally using MNAND and/or MNOR for all inputs 000 or 111)
if lasted a few cycles only (avoid randomness insanity)

DO NOT train, just self-train for simplicity (IO=GF). 
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
  all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
  link (N ins, M outs), delayed out for 1 timeslice, can randomly grow/split with freq
  cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow
  reaction to signal and delayed signal - basis for pattern recognition

1 in - 1 out  = random strategy is the best, 0->r
1 in - 2 outs = outward spiral is the best, 0->s
2 in - 2 outs = "outward spiral" / "downward spiral", smooth shape tracking, no internal model, 0->s, 1->t 

2 in - 2 outs (stereoscopic vision) is just optimized version of 1 in - 2 outs (better entering phase).
let's use 1 in - 2 outs for now for everything.

==> The problem is that when Ins are "close" you can't rely on them to track long periodical changes.
==> And interestingly enough 1 In is good enough to follow borders (2 Ins are still better at entering phase)!
    consider 2 Ins as "optimization".

next - 2nd level:
goal - track slower In changes, so with predictions you can actually deviate from 1st level "border" so maximize
Ins over time overall.
example  |||||||||| ?

prediction - continue reaction when no input? NO! see example above. This is second-order harmonic, when we flip
second level movement L <-> R.

symmetry level 1 - line (straight, curved)
symmetry level 2 - group of lines - lattice
symmetry level 3 - group of lattices
etc?

actually there are many ways to discover symmetry, even consuming simple |||||||||| which one is the best?
min! (as always) for min time consume max food/info. In this case - left to right or in reverse, not like circles.
so same "wave" movement pattern is optimal at all levels?

And btw, food <-> info seems to be antonyms? more stability (food) - less info (chaos?)

so 2nd level - the same as 1st one but longer timeout for "metric collection" (-:-), not 5, but 50 periods for example
if 1st and 2nd level are disjointed  (not linked) we may miss on some food, those long ones will be skipped:

|||||||||||||
    |    |
    |    |

ideal path to consume the whole lattice:
/\/\/\/\/\/\/

compare relative food increase or there is some min? like in 50 period, 1 vs 2 is increase or no reaction?

and again - synchrony (universal GF) / gravity / probability / choice - reflections
? many connected downlinks on a single In - combined momentary capacity (OR) -> pwm - same amplitude, diff signal length

***************** Feb 2021 ***************** 

spatial/temporal symmetry via SYM elements (internally using MNAND and/or MNOR for all inputs 000 or 111)
if lasted a few cycles only (avoid randomness insanity)

DO NOT train, just self-train for simplicity (IO=GF). 
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
  all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
  link (N ins, M outs), delayed out for 1 timeslice, can randomly grow/split with freq
  cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow
  reaction to signal and delayed signal - basis for pattern recognition

1 in - 1 out  = random strategy is the best, 0->r
1 in - 2 outs = outward spiral is the best, 0->s
2 in - 2 outs = "outward spiral" / "downward spiral", smooth shape tracking, no internal model, 0->s, 1->t 


==> The problem is that when Ins are "close" you can't rely on them to track long periodical changes.
==> And interestingly enough 1 In is good enough to follow borders (2 Ins are still better at entering phase)!
    consider 2 Ins as "optimization".
next - 2nd level:
goal - track slower In changes, so with predictions you can actually deviate from 1st level "border" so maximize
Ins over time overall.
example  |||||||||| ?


different periods ("density") and / or phase shift ("shapes") handled with tracking:
  left  gain -> right gain           = reverse if left  thrust
  left  loss -> right loss           = reverse if left  thrust
  left  gain/loss -> right gain/loss = reverse if left  thrust
  right gain -> left  gain           = reverse if right thrust
  right loss -> left  loss           = reverse if right thrust
  right gain/loss -> left  gain/loss = reverse if right thrust

==> co-directional arrows seems to be working great. Only watch for Gain/Loss per channel and once flipped 
==> in the same direction check if action should be reversed. Note that we memorize last state, like once
==> gain/loss occured in L channel we wait till the same event (gain or loss) = "co-directional arrows" occurs in other

  // 1) side concept (if we know it's on the right, that's where we need to move => better predictions)
  // 2) unified metric for curve / phase (now seems different for different sides?)
  // 3) apply neuroplasticity?
unified metric 2) won't work on level 1, that's exactly why we need level 2,
and we need to feed not direct IO but signals from level 1 "turning to good side"/"turning to bad side", see 1) above
so on level 2 tracking level 1 "both gaining" events.

sample: density is increasing, how to figure out what to do - turn or not without second data point?????
if you go in circles (spyral) and noticed periodical density increase (twice increase or twice decrease)???
that doesn't work well

how to distinguish which channel gained/lost first for longer periods? it seems to happen simultaneously??
I guess it should work. But up/down level periods should be close enough, like 1 -> 10 -> 100, not 1 -> 100
as at 1 -> 100 it's hard to catch at 100 level inner waves at 1 but at 10 it's more precise where we're moving L/R?

=> longer periods we compare food in the current cycle per each channel.

predictions:
 -calculate one average period for both channels;
 -wait till we "missed my period" ;-) by ~30-50% and initiate turn;
 -that turn should be bigger by ~30-50% to compensate and/or establish "wide search" pattern?
 

?=> to check for gain / loss use timeout (reference wave * X), different for every level (or even seld-tuning delay)
?=> when receiving Ins from lower level we're tuning/memorizing period/phase and once GF != 0 (lowest level In)
?=> control level 1, send our last memorized wave 2 to level 1 and this control wave may either be 
?=> in phase ("L" turn) or counter-phase ("R" turn) depending on level 2 gain/loss
?===> generally it's no matter where we're going at lower level when "signal is lost", we just continue ?
?===> OR at each level we're getting GF but measure own level's "density" to turn based on that?


how to watch for gain/loss at level >= 2 as at level 2 In there could not be this situation below,
we're not "turning again and again":

L ********************************
R **************

it's always             or

L ***************       L **************
R **************        R ***************

maybe constant switching L -> R -> L -> R, and same with In: expecting 1 -> 0 -> 1 -> is more productive / symmetric
concept across all levels?


prediction - continue reaction when no input
and again - syncrony (local gf) / gravity / probability / choice - reflections
many connected downlinks on a single In - combined momentary capacity (OR) -> pwm - same amplitude, diff signal length
seld-tuning delay, if we compare reflected turns vs actual - this is like Ins


***************** Dec 2020 ***************** 

spatial/temporal symmetry via SYM elements (internally using MNAND and/or MNOR for all inputs 000 or 111)
if lasted a few cycles only (avoid randomness insanity)

DO NOT train, just self-train for simplicity (IO=GF). 
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
  all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
  link (N ins, M outs), delayed out for 1 timeslice, can randomly grow/split with freq
  cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow
  reaction to signal and delayed signal - basis for pattern recognition

1 in - 1 out  = random strategy is the best, 0->r
1 in - 2 outs = outward spiral is the best, 0->s
2 in - 2 outs = "outward spiral" / "downward spiral", smooth shape tracking, no internal model, 0->s, 1->t 

different periods ("density") and / or phase shift ("shapes") handled with tracking:
  left  gain -> right gain           = reverse if left  thrust
  left  loss -> right loss           = reverse if left  thrust
  left  gain/loss -> right gain/loss = reverse if left  thrust
  right gain -> left  gain           = reverse if right thrust
  right loss -> left  loss           = reverse if right thrust
  right gain/loss -> left  gain/loss = reverse if right thrust

==> co-directional arrows seems to be working great. Only watch for Gain/Loss per channel and once flipped 
==> in the same direction check if action should be reversed.

prediction - continue reaction when no input. Simple model - reflection. Assume fixed distance 
1st <-> 2nd level link => one fixed period.

and again - syncrony (local gf) / gravity / probability / choice - reflections
many connected downlinks on a single In - combined momentary capacity (OR) -> pwm - same amplitude, diff signal length

=> different periods ("density")?  actually time wise periods should be the same!? With higher density it's just
less distance but same time?

                LLLLLLLLLLLLLLLL1              LLLLLLLLLLLLLLLL1              LLLLLLLLLLLLLLLL1
                LLLLLLLLLLLLLLLL2      LLLLLLLLLLLLLLLL2      LLLLLLLLLLLLLLLL2
                LLLLLLLLLLLLLLLL3        LLLLLLLLLLLLLLLL3         LLLLLLLLLLLLLLLL3
                *****************        *****************         missed

  *****************         *****************         ***************************************************
  RRRRRRRRRRRRRRRR1         RRRRRRRRRRRRRRRR1         RRRRRRRRRRRRRRRR1
  RRRRRRRRRRRRRRRR2      RRRRRRRRRRRRRRRRR2      RRRRRRRRRRRRRRRRR2 
  RRRRRRRRRRRRRRRR3             RRRRRRRRRRRRRRRRR3             RRRRRRRRRRRRRRRRR3

a) even if reflection period is just slightly off it will soon be completely unphased (in just few cycles)
b) however periods ****    **** themselves are not really stable ("variable density")

L and R seeing pretty much the same (almost) IN but with delay?
1st level - fixed delay
2nd level - seld-tuning delay?

if we compare reflected turns vs actual - this is like Ins. how to react - same, but 2nd level R/L?
two more patterns to handle or they are likely to happen with Ins, just less often?

1) if there's input (1st level out) and no reflections yet - create one
2) if there's input (1st level out) and a few reflections and they are close enough     - choose closest
3) if there's input (1st level out) and a few reflections but they are not close enough - create one
4) if there's no input (1st level out) - follow closest reflection

there should be only 1 SYN cell 2nd level for both 1st outputs?
what exactly is 2nd level action? same - L/R or??? consider one side for now. see above, adjusting delay.

ok, so as reaction we're adjusting delay, but what is output then? even / or 2 outputs?
and how L and R sides connected?
technically with "adjusting delay" logic we just need 1 In, not 2! 
so use 2 for L and R? still - outs? may be now those 2nd level outs should replace 1st level as smarter ones?
so what gain/loss means in this situation now on 2nd level? 
what situations 2nd level decisions should handle? why we need it? evolutionary benefits? 
track "dotted lines" or what????????????????? anything with sudden change of direction, sharp angle, to recognize 
meta-structure

=> reverse 2nd level direction - producing periodical "wave" same as last known
=> but either in direct or reversed phase based on period change gain/loss?
=> this should also work for 1st level logic!
=> is there a control loop? controlling low level L/R from second level via 1st? otherwise how to produce "wave"?
=> right, no direct output from 2nd level possible to replace 1st level out as they even work at diff freq!
=> and btw, "wave" should be "outward spiral"? rather smooth. Could be. Or better if we continues saved "wave".
==>
==> 1st level producing wave 1 freq 1 (high) and with timeout 1 (low) checking gain/loss, producing Up signals when switching
==> 2nd level consuming those signals freq 2 (lower) determine with timeout 2 (large) if they are periodic like wave 2
==> (regular in/switch level 1 within timeout 2) it's ok, but when timeouted with both gain or both loss - time to 
==> control level 1, send our last memorized wave 2 (period, usually fixed / timeout 2 dependent & phase) to level 1
timeout 2 is much bigger wave 2 control period (L/R action)?

lev 1 and 2 still anymmetric in terms of output, how about 2 and 3, etc?

period change gain/loss = second level sensor/trigger, density metric
phase shift             = second level "current direction", shape metric

            2nd level SYM
             | | | | | |
    normal, n|d| |n|delayed (self-adjustable), reflected to generate wave
             | | | | | |
              \/ \/  | |
               ^ ^   | |
GF ????       L|R|  L|R|
               | |   | |.           .       
               | |   | |      .           .      
               | |   | |
               | |   ~ ~
Raw In L ---> 1st level SYM ---> Raw In L  ......      .......
Raw In R --->               ---> Raw In R        ......      .......

in the absence of level 1 input, same freq generated:
                                           . . . . . . . . . . . . .
                                            . . . . . . . . . . . . .

conflicting level 1 L/R action and level 2 "control" actions:

L l        lL       
      Rr        r R      

should be ok - if periods close enough, overriding signals just slightly affect trajectory
but when level 1 signals are missing, level 2 signals are naturally taking over as the only ones present!

or alternatively - level 1 control is not in charge anymore at all, only affecting level 2 current period values
which is actually controlling level 1

so the q is - level 2 generated signals are endless?
most likely yes, our level 2 model is adaptable (saves last period/phase) but in the absense of better approach, level 1
model what else to do?

Is it enough to track L/R signals to notice changes in period? don't we need "reference" high-freq signal to measure against?
comparison with immediate last value (cubegl.cpp, rev 3) would only work if processing speed = wave speed, but
if we need to wait a while then TIMEOUT can regulate it? reference signal can "measure" timeout if we need to increase it?
TIMEOUT = average period between gain/loss/control events = normal output period
endless switch L -> R -> L -> unless we have input during timeout

maybe we need 3 states - gain / loss / (no change / unknown change)
timeout to determine gain/loss (1st level wave) << timeout to determine no change (2st level wave period)
ok!

how is GF involved? so maybe GF -1 as absence of inflow = switch to endless control  is being propagated up to
2nd level, 3rd, etc??

***************** Oct 2020 ***************** 

spatial/temporal symmetry via MNAND and/or MNOR for all inputs 000 or 111 
if lasted a few cycles only (avoid randomness insanity)

DO NOT train, just self-train for simplicity (IO=GF). 
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
  all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
  link (N ins, M outs), delayed out for 1 timeslice, can randomly grow/split with freq
  cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow
  reaction to signal and delayed signal - basis for pattern recognition

1 in - 1 out  = random strategy is the best, 0->r
1 in - 2 outs = outward spiral is the best, 0->s
2 in - 2 outs = "outward spiral" / "downward spiral", smooth shape tracking, no internal model

0->s
1->t 

different periods ("density") and / or phase shift ("shapes") handled with tracking:
  left  gain -> right gain = left  thrust
  left  loss -> right loss = left  thrust
  right gain -> left  gain = right thrust
  right loss -> left  loss = right thrust


2 in - 2 outs = rough shape tracking ("dotted line"), fixed period

0 for >>p period ->s
0 for   p period ->f reflections, till "long period" reached
1->t with period p

prediction - continue reaction when no input. Simple model - reflection.
model (reflections) is only in effect when there's no IN.

left/right thrust - reflected from 2nd level. Assume fixed distance 1st <-> 2nd level link => one fixed period.

when there's no IN? suppose IN period = reflection length ("fixed period" here).
then reflection must match IN, when missing IN = use model
problem again with variable period length - can't tell if period length changes or we missed existing end-of-period.
assume existing end-of-period, one model at a time!

late:  so if not found OUT matching to reflection => existing end-of-period, start using the existing model
early: or if found OUT earlier                    => period length changes, create new model? also if phase changes.

all natural OUTs: either do nothing/left/right.

q: reflections to the same upcell from both 1st level OUTs? or different but the same length?

better from the same, period should be in sync, phase may change but L & R period should be the same, otherwise
movement's coordination will suffer (e.g. LLRR...... LLLLLRRR... unstable)

actually must be the same parent to track phase change.


q: interference with "spyral mode"? need to ignore the existing model "corrections"
or maybe not. Model is always right, if it's not right, let's create a new model. All the time. Chicken and egg.

Model is right = Gf > 0 "charge is growing"
when to switch ^^^^^ to the most fitting model

Model is not right = Gf < 0 "charge is depleting" while it should not? being attacked?
when to switch ^^^^^ to the least fitting model

for the model - Gf is not long term "fat" / one's size, rather short term, 
food is coming > 0 | pain < 0, very low on food = pain;

q: now how to switch between models? Graph of transitions. We have these models: 

4. random                   - no Gf expectations
3. spyral (last hope)       - no Gf expectations
2. reflection (1 node wave) - Gf > 0
maybe reflection from 2/3/more uplinks with more complex wave form.
1. moth/B-W tracking (main) - Gf > 0, if not - no food (use best model) or being attacked (use bad model/random)
0. do nothing               - Gf = 0

seems like we need to select best reflection matching existing B/W track and use it. no. curves, create new?

and again - syncrony (local gf) / gravity / probability / choice - reflections / D-Class amp, amplitude -> pwm
This type of modulation is also often referred to as "natural sampling" where the triangle-wave oscillator acts as 
the sampling clock. 

many connected downlinks on a single In - combined momentary capacity (OR) -> pwm - same amplitude, diff signal length
problem - pwm freq should be * 10 (at least?) and how is that symmetrical if that output is being fed to another In??
maybe it's not a bug but feature? freq is highest at the entry and goes down with processing.

how is MNAND / MNOR involved in tracking? see Jun 2020 "It does."! 0/3 scenario?

=> different periods ("density")?  actually time wise periods should be the same!? With higher density it's just
less distance but same time?

assume all periods are the same. walking along wall, one side barrier, single reflection would work for one direction?

ins:

   ***********               ***********
*****************         *****************

turns:
              *****************         *****************
*****************         *****************

                 ***********                ***********  
***************               ***********  

same side vs reflections:
                                        RRRRRRRRRRRRRRRRR
              *****************         missed
*****************         *****************
                           RRRRRRRRRRRRRRRRR

if we compare reflected turns vs actual - this is like Ins. how to react - same, but 2nd level R/L?
two more patterns to handle or they are likely to happen with Ins, just less often?


get back to moth/B-W tracking logic (more generic):
and, still, better not to use timeout
directional arrows? co-direction? yes! seems to be working the best!

                            right turn        |     left turn
                            __________________|______________
                                              |
1)   ***********    L gain, no actions        |     reverse 
       *********                              |
                                              |
2)   *********      L loss, no actions        |     reverse
     ***********                              |
                                              |
3)   ***            L gain-loss, no actions   |     reverse
          ***                                 |
actually it's like L loss as gain is overriden|
                                              |
                                              |
1a)  ***********    forgotten, no actions     |     no actions
             ***                              |
                                              |
2a)  **             forgotten, no actions     |     no actions
     ***********                              |
                                              |
3a)  ***            forgotten, no actions     |     no actions
             ***                              |
                                              |
same forgotten (timeout) cases for R          |
                                              |
4)     *********    R gain, reverse           |     no actions
     ***********                              |
                                              |
5)   ***********    R loss, reverse           |     no actions
     *********                                |
                                              |
6)        ***       R gain-loss, reverse      |     no actions
     ***

logic should be simple and also handle complex cases like:  side with changes (no matter gain/loss)

     ***       ***        right turns / L gain-loss, no actions / R gain-loss, reverse
          ***
                                              left turn logic now        right turn logic now
     *****************    right turns / R loss, reverse / L gain, reverse / R loss, reverse
     *******  ******
                                              left turn logic now        right turn logic now        left turn logic now
     ***********  ******  right turns / R loss, reverse / L gain, reverse / L loss, no actions / R gain, reverse / R loss, no actions
     *******  ******

                00        same as this?
            00       000


***************** Jul 2020 ***************** 

spatial/temporal symmetry via MNAND and/or MNOR for all inputs 000 or 111 
if lasted a few cycles only (avoid randomness insanity)

DO NOT train, just self-train for simplicity (IO=GF). 
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
  all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
  link (N ins, M outs), delayed out for 1 timeslice, can randomly grow/split with freq
  cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow
  reaction to signal and delayed signal - basis for pattern recognition

1 in - 1 out  = random strategy is the best
1 in - 2 outs = random strategy for 1 out, (except "fed up"), for 2-nd inverted in, "inverted saw", not random, 
just less periodical, so 1 out / direction - heartbeat high freq, 2nd out / direction - low freq
result - "outward spiral" movements, line is quite difficult to implement, and no "shape tracking" possible
2 in - 2 outs = "downward spiral", shape tracking, no internal model, works for lines or "quasi-lines", see below

2 in - 2 outs = "downward spiral", shape tracking, with internal model
expecting L   11100011100011100... line
expecting R   01110001110001110... line
getting       11100011100000000... square
                         ^^^ what do we do at that point?
wait and get  11100011100000000111... square, now this is our new model, expecting this, not line, how do we use it?

grow = means = creating / using a new model
model is only benefitial if we use it

now: 2 in - 1 cell - 2 outs, there's no model yet, not really expecting anything at all
actually this is a model - that logic below and it's expecting "line/quasi-lines" to work well 

left  gain -> right gain = left  thrust
left  loss -> right loss = left  thrust
right gain -> left  gain = right thrust
right loss -> left  loss = right thrust

integral - tracking patterns 3 x 3 000...111...000,    temporal symmetry
synchronous decision, based on BOTH inputs - L and R,  reaction to temporal asymmetry
symmetrical - left and right turn logic is identical,  spatial symmetry

less time between 1 & 2 => higher thrust

more sophisticated model for example:

left  gain 000111 -> right gain = left  thrust 0000001, right thrust -> left thrust
left  loss 111000 -> right loss = left  thrust 0000001
right gain 000111 -> left  gain = right thrust 1111110, left thrust  -> right thrust
right loss 111000 -> left  loss = right thrust 1111110

real thrust gain -> expected thrust gain?
0000001111111000000011111110000000 thrust
0000000111111100000001111111000000 expected (model, line from heartbeat)

0000000111111100000000000000000000 - now what? how do we expect a few "left turns" (square model)?
or may be that's just dotted line? how to make a difference?

stop and outward spiral again? what about non-liner reaction? spiral or no spiral doesn't matter,
any reaction will do:
line        = left/right thrust => periodical IO in left and right channel
dotted line = left/right thrust => periodical IO in left and right channel, no IO, periodical IO again, ...
square      = left/right thrust => periodical IO => no IO (still left/right thrust) => no IO (right thrust) => periodical IO => no IO => right thrust => periodical IO 

and that's called reflection, so second level is watching / tracking 1-st level actions and judge by average (?)
IO collected like long dotted line is better than small square (long / small terms - may be 2/3/.. level reflections)

reflection should be symmetrical (same logic at all levels), action -> symm response from L & R (1st level is easy
how to do that at 2nd?)

tracking 1-st level actions only as 2 IOs and now our 3 (??) super-action is to alter those actions? like 
left/right thrust => right only thrust => left only thrust?
problem - either left or right thrust, not overlapping
dots - line crossings
from 1st level perspective - outs L or R
from 2nd level perspective - outs L for a while or R for a while or L/R switching for a while 
suppose we smooth out "L/R switching for a while" and "R for a while"..., so we have either  L2 / R2 / L2
but how to make it stereo? suppose we have second level thrust TL2 / TR2

ok, let's translate "L/R switching for a while" => 1 / 1, like "normal flow", no corrections needed
this may only be identified by keeping the period about the same.
each level has its own "freqency"? depends on thrust power and pattern width (3-5-7)
if real down-level signal != our period, switch out like:
"R for a while" => 0 / 0 delayed
"L for a while" => 0 delayed / 0
to check for the period - when L/R is switching, issue a signal, returning back with delay (reflecting) and 
check if signal = returning signal. The delay should be rather constant and level dependent as explained above.

q. - looks like 2nd level period is not stable? like 50% 1 / 50% 0, but may vary a lot?
another definition, either don't care about length:
 L/R switching  -> one second level signal, type 1
"R for a while" -> one second level signal, type 2 
"L for a while" -> one second level signal, type 3
or combine:
L/R switching for 5 periods & R for a 3 periods -> one second level signal 

still confusing - 1st level (border - 2 types), 2nd level - 3 types?
q. - how to reduce 3 types to 2? consider type 1 - type "ok", type 2/3 - type "not ok"?
yes, see above "R for a while" => 0 / 0 delayed
just model "dotted line"

q. so 2nd level is trying to keep 1st level freq the same till 2nd level freq is discovered?
What to do at 2nd level when 1st level freq is clearly broken? move forward?

ok, let's move forward (makes sense: imaginary/target line, predator-prey) but how? 
how to replicate the same freq "wave"? this is our first simple "prediction"
if something goes for 10 periods, it will likely to continue.
Anyway, 1st level is reactive, so "wave" should be generated at 2nd?
how to produce wave - positive backfeed with delay? what is called "reflection"

on every level we know where we're currently moving, "left" (small left on 1st, larger on 2nd) or "right"
suppose 1st level determined its own "wavelength" and once we miss cycle we consult 2nd level - where to go?
actually if we just send signals up to 2nd level when "making decisions/turns" left/right
then 2nd level can make its own "big turn"

problem: 
send signals when "making decisions" to both 2 level IO? like 1/1 when turning, 0/0 when not, 
how to make a transition 1/0, 0/1? maybe we should send 1/0 or 0/1 for left and right turns? and 0/0 when not.
then last turning state is clear.

IO patterns
chI L: 00000111110001111100 00000000000000000000
chI R: 00000011100000111000 00000000000000000000
actions 1 level
chA L: 000000.0000000.00000 00000000000000000000
chA R: 0000000000.0000000.0 00000000000000000000
actions 2 level
chA L: 00000000000000000000 00.00000000000000000 ? see below or 
chA R: 00000000000000000000 000000.0000000000000                we just noticed signal loss here?

so "actions 1 level" are being reflected by level 2 back as actions, so in fact:

actions 2 level (delayed reflection, just once!)
chA2 L: 00000000000000.00000 00.00000000000000000
chA2 R: 000000000000000000.0 000000.0000000000000

the question a) what level 2 sends to level 3? 1 signal when chA2 gain / loss detected
             b) we do need to react differently? follow (food) / run (predator, next level, eons later)
the problem  c) different periods and / or phase shift, how to reflect? different parents????
             no need to change logic / add levels as different periods and / or phase shifts are handled well already!

             like cerebral hemispheres and then interconnect 
         \
    *out  \?
    |     /
    |diff/
*___*___* gain/loss detection
|       |
*in1    *in2

               c1) on each side ("diff shapes") or in between, like:

                 000001111100000111110000011111  raw in, line
                 000011111110001111111000111111

                 000000011100000001110000011100  raw in, phase shift
                 000000111110000011111000111110

                 L....R....L....R....L....R....L
                 L......R..L......R..L......R..L  phase shift ("shape", moving left)
                           or by channel:
                 L.........L.........L.........L
                 .....R.........R.........R.....

                 L.........L.........L.........L  phase shift ("shape", moving left)  
                 .......R.........R.........R...  phase shift ("shape", moving left)
                 see below "less time between 1 & 2 => higher thrust" 

                 1111100000111110000011111000001
                 0000011111000001111100000111110  raw out, line

                 1111111000111111100011111110001  raw out, phase shift ("shape", moving left)  
                 0000000111000000011100000001110

                 like running along border in circles
                 1111110001111111000111111100011
                 1000111111100011111110001111111  "extended / slow" raw out, line

                 1110000000011110000000011110000
                 1000011110000000011110000000011  "extended / slow" alt raw out, line

                 RRRRLLLLLLLLLLLLLLLRRRRRRRR ???  second level


                 L....R....L....R....L....R....L
                 L...R...L...R...L...R...L...R... freq shift (smaller turns)
                           or by channel:
                 L.........L.........L.........L  
                 .....R.........R.........R.....

                 L.......L.......L.......L....... freq shift (smaller turns, rough environment / higher density)
                 ....R.......R.......R.......R... freq shift (smaller turns)
                "less time between 1 & 1" / "less time between 1 & 2" both / proportionally?


               c2) after "reset" ("another shape coming")
reflection is the key to sustain the period / make a prediction

or level 1 is getting reflections from many (a few) level 2 cells and choose (follow / approve)
only the right one - with the same period?

or
chI L: 00000011100000111000
chI R: 00000111110001111100
actions
chA L: 0000000000.0000000.0
chA R: 000000.0000000.00000



q. - how to apply action from 2nd level? it's less frequent, so maybe the same "effectors" but additive? 
small corrections?


***************** Jun 2020 ***************** 

spatial/temporal symmetry via MNAND and/or MNOR for all inputs 000 or 111 
if lasted a few cycles only (avoid randomness insanity)

DO NOT train, just self-train for simplicity (IO=GF). 
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
  all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
  link (N ins, M outs), delayed out for 1 timeslice, can randomly grow/split with freq
  cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow
  reaction to signal and delayed signal - basis for pattern recognition

1 in - 1 out  = random strategy is the best
1 in - 2 outs = random strategy for 1 out, (except "fed up"), for 2-nd inverted in, "inverted saw", not random, 
just less periodical, so 1 out / direction - heartbeat high freq, 2nd out / direction - low freq
result - "outward spiral" movements, line is quite difficult to implement, but no "shape tracking" possible
2 in - 2 outs = "downward spiral", tracking edge, see below

^^^^ how MNAND/MNOR works here? It does.

Start with border, go along border. This is like "downward spiral" with 100% guarantee to find it all!
monocular IO is not enough for that, only bino. So we need to track:
1) left side IO gain / loss
2) right side IO gain / loss
3) time bewteen 1 & 2? can react only after both changed or timeout?

after testing: 
best to track pattern 3 x 3 000...111...000
gain/loss & loss/gain reactions are not helping, only gain/gain loss/loss

currently right thrust: left  gain -> right gain = left  thrust
currently right thrust: left  loss -> right loss = left  thrust
currently right thrust: right gain -> left  gain = right thrust
currently right thrust: right loss -> left  loss = right thrust

currently right thrust: left  gain -> right loss = left  thrust optional? not really helping
currently right thrust: left  loss -> right gain = left  thrust optional?
currently right thrust: right gain -> left  loss = left  thrust optional?
currently right thrust: right loss -> left  gain = left  thrust optional?

currently left  thrust: left  gain -> right gain = left  thrust
currently left  thrust: left  loss -> right loss = left  thrust
currently left  thrust: right gain -> left  gain = right thrust
currently left  thrust: right loss -> left  loss = right thrust

currently left  thrust: left  gain -> right loss = right thrust optional?
currently left  thrust: left  loss -> right gain = right thrust optional?
currently left  thrust: right gain -> left  loss = right thrust optional?
currently left  thrust: right loss -> left  gain = right thrust optional?

less time between 1 & 2 => higher thrust
more time between 1 & 2 => less thrust

and in fact no 3rd variable (current state, thrust), so can simplify:

left  gain -> right gain = left  thrust
left  loss -> right loss = left  thrust
right gain -> left  gain = right thrust
right loss -> left  loss = right thrust


And need periodical decision making, not instant? 1-3-5 time slots - integral / asynchronous (L and R) / symmetrical
integral - see above "pattern 3 x 3", averaged over 3 time slots
asynchronous? Actually decision is synchronous as based on BOTH inputs - L and R.
symmetrical - yes as left and right turn logic is identical;

***************** Feb 2020 ***************** 

gravity
spatial/temporal symmetry via MNAND and/or MNOR for all inputs 000 or 111 
if lasted a few cycles only (avoid randomness insanity)

DO NOT train, just self-train for simplicity (IO=GF). 
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
  all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
  link (N ins, M outs), delayed out for 1 timeslice, can randomly grow/split with freq
  cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow
  reaction to signal and delayed signal - basis for pattern recognition

3 levels Cell out 1/0/10 matches to 3 actions with "random approximate movement":
start action         - all 0  In, excitation, heartbeat in 2 outs maybe other way around? stable 1 out?  interesting!!!
continue/do nothing  - random In,           , heartbeat in 1 outs maybe other way around? random 2 outs? random or how?
stop action          - all 1  In, inhibition, no heartbeat / outs

continue/do nothing -  "random 2 outs? random or how?" saw like logic! 1 out - steady, 2 out - random?
below: 4) simpliest model 1 IO = GF, later GF is more like internal energy status. Random strategy is the best in the case;

1 in - 1 out  = random strategy is the best
1 in - 2 outs = random strategy for 1 out, (except "fed up"), for 2-nd inverted in, "inverted saw", not random, just less periodical
so 1 out / direction - heartbeat high freq, 2nd out / direction - low freq
result - spyral movements, line is quite difficult to implement, but possible
1 in - 3 outs = line is easy to implement, how? easy - 1 cell with 2 normal outs (diff freq) and delayed out!

1 cell with 1 in - 3 outs or 2 cells with 1 in - 3 or 4 outs = 1 + 2 or 2 + 2?

random:       1 (heartbeat, no real In) -> 1 out  (random), unrealistic (there should always be In for enery influx)
smart random: 1 In                      -> 1 out  (0 -> random, 1 -> 0)
spiral:       1 In                      -> 2 outs (diff freq, random or later periodical, 00 -> 11, 11 -> 00, 01/10 -> 10)
moth path:    1 In                      -> 2 outs (diff freq) & delayed out, 00 -> 111d, 11 -> 000, 01/10 -> 110d or 101d?)

spiral/moth path: 1 In                  -> 2 outs, 00 -> 110d or rather 101d, yes!?, 11 -> 000, 01/10 -> 111d
2 ins -> 2 outs (crossover)

=> FYI: for moth path simple second delayed out is not enough! need to slow down second output. How? 
timer, freq div in a loop? this is actually second derivative vs periodical heartbeat!
anyway, how to change freq? maybe it's coming naturally - like energy saving measure? No In stimulus - less freq out?

so if initially we are reacting to IO gradient, now we should react to second gradient? rather minus second
as we go from long to short reaction periods:
first gradient - long period changes
second gradient - shorter period changes
... etc

111111111000000000
.   a   .    b   .  a->b down                        \ combine?
. c . d . e  . f .  c->d same, d->e down, e->f same  /

let's start with a goal - how do we need to function to collect IO faster for complex objects?
ex: cube - random vs spiral vs ...??  
start with border, go along border. This is like "downward spiral" with 100% guarantee to find it all!
monocular IO is not enough for that, only bino. So we need to track:
1) left side IO gain
2) right side IO gain
3) time bewteen 1 & 2? can react only after both changed?

so
right gain -> left  gain = right thrust
left  gain -> right gain = left  thrust
right loss -> left  loss = right thrust
left  loss -> right loss = left  thrust
right gain -> left  loss = left  thrust
left  gain -> right loss = right thrust


moth path shoud always be combined with spiral, otherwise ineffective!
normally moth path -> spiral or spiral -> moth path or no diff? well, spiral -> moth path seems the best solution.

inhibitory / excitory neurons?

how about augmented MNAND/MNOR:
00 -> 10
11 -> 00 (not absolute 0? rare aperiodical 1s on both outs?)
10 / 01 -> 11

would result in simple moth/spiral network:

In -> Cell1 -> Out 1 (fast) -> Cell2 -> Out 2 (slow)
       |                         |---> ??    
       |
       ----------------------> Cell3 -> Out 3 (slow)
                                 |---> ??

or maybe just 1 cell with 3 outs? like SMNAND/SMNOR (slow memory):

period 2
00      -> 110 (fast/slow/nothing)
11      -> 000 (maybe slow random all 1s would work too)
10 / 01 -> 111 (fast/slow/slow delayed)

this is freq divider / delayer (alt: freq multiplier), based off heartbeat
see below - 2nd level freq should be based of 1st outs, not heartbeat? no, still off heartbeat but divided
otherwise we can't reproduce pure "second level" freq? Or can we? basically we get 1 fast out almost ALWAYS 
(except for 111 in, content) so can we use it then?

q - most effective way to clean "long extended rect area" - not spiral (lots of wasted energy for extra circle if miss), 
not spiral/moth in some direction (lots of wasted energy if moth path direction is wrong) 
but spiral/moth in the right direction. How second cell can help with that?

second derivative - not just noticing 01/10 but "signal stream density increase/decrease"?
delayed out = average over time / density, so if we watch that out #3 (slow delayed) and redirect as In to cell2
that cell can check second derivative?

period 3, 1 IN, 3 OUTs
000                         -> 110 (fast/slow/nothing)
111                         -> 000 (maybe slow random all 1s would work too)
110 / 001 / 010 / 011 / etc -> 111 (fast/slow/slow delayed)

101010101010101010101 -> 1  1  1  1  1  1  1 ->          0/0/0         0/0/0
111110011110011100110 -> 0  1  1  1  1  1  1 ->          1/1/1         0/0/0

why we're feeding "slow delayed" out to 2nd level?
so at second level we track those batches 111 ?  111 -> s1, like s1, s0, s0, s1

fast/slow/nothing        - right deviation
fast/slow/slow delayed   - straight, right moth path (on 3D - spiral)
do we need left deviation to get evolutionalry / any advantage?? should be as doing 350 degree is slower than -10.

fast/slow/fast           - left deviation too? no, will produce asymmetrical moves vs right spiral
fast/nothing/slow        - left deviation - spiral
fast/nothing/slow        - from another cell? left / right sides for 1 controller? Don't we need 2 IOs? I guess.
fast/slow delayed/slow   - straight, left moth path (on 3D - spiral)

>>>>> easiest way for moth-path to follow "light" is with 2 INs:
>>>>>   if both signals are getting weak - wrong path
>>>>>   one is gettings stronger (more frequesnt), another one is gettings weak and vice versa!!!!

and on 2D no need for 3 OUTs, 2 is enough under 90' (for 3D, yes, 3 OUTs)!!

period 3, 1 IN, 2 OUTs
000                         -> 11s (fast/slow)
111                         -> 00  (super slow :-)
110 / 001 / 010 / 011 / etc -> 11d (fast/fast delayed or better slow / slow delayed)

so in fact 1 cell still generates 3 different states / outs (like MNAND)


period 3, 1 IN, 2 OUTs, simplified
000  -> 11s (fast/slow)
111  -> 00  (super slow :-)
else -> 11d (fast/fast delayed or better slow / slow delayed)

period 3, 2 INs, 2 OUTs (crossover), looks like we're reacting to gradient, 2nd derivative?
000 / 000  -> 11s (fast/slow)
000 / 111  -> 
000 / else -> 
111 / 000  -> 
111 / 111  -> 00  (super slow :-)
111 / else -> 

period 2, 2 INs, 2 OUTs, reacting to gradient, 2nd derivative
00 -> 11 (fast/slow)
01 -> ?0 (?/nothing)
10 -> ?1 (?/fast)
11 -> 00 (nothing/nothing)

00 -> 11 (fast/slow)
01 -> 0? (nothing/?)
10 -> 1? (fast/?)
11 -> 00 (nothing/nothing)

period 2, 2 INs, 2 OUTs (combined), reacting to gradient, 2nd derivative

00 / 00 -> 21 (fast/slow)
00 / 01 -> 01 (nothing/slow) same as 10 / 01
00 / 10 -> 22 (fast/fast)    same as 10 / 10
00 / 11 -> 01 (nothing/slow) same as 10 / 01

01 / 01 -> 11 (slow/slow)
01 / 10 -> 10 (slow/nothing)
10 / 01 -> 01 (nothing/slow)
10 / 10 -> 22 (fast/fast)

11 / 00 -> 10 (slow/nothing) sym to  00 / 11
11 / 01 -> 11 (slow/slow)    same as 01 / 01
11 / 10 -> 10 (slow/nothing) same as 01 / 10
11 / 11 -> 00 (nothing/nothing)

01 / 00 -> 10 (slow/nothing)  sym to 00 / 01
10 / 00 -> 22 (fast/fast)     sym to 00 / 10, same as 10 / 10
01 / 11 -> 11 (slow/slow)     sym to 11 / 01, same as 01 / 01
10 / 11 -> 01 (nothing/slow)  sym to 11 / 10, same as 01 / 10 

what topology would fit into the logic?

2 cells (gradient In up-> gradient Out down and vice versa) interdependent / connected via reflections?


period 2, 2 INs, 2 OUTs (combined), reacting to gradient, 2nd derivative, sorted

out 6 combinations out of 9 possible

00 / 00 -> 21 (fast/slow)
11 / 11 -> 00 (nothing/nothing)

?two cells passing-through every second signal with one actuator or just black box?:
edible vs non edible?

00 / 10 -> 22 (fast/fast)    same as 10 / 10
10 / 10 -> 22 (fast/fast)
10 / 00 -> 22 (fast/fast)     sym to 00 / 10, same as 10 / 10

01 / 11 -> 11 (slow/slow)     sym to 11 / 01, same as 01 / 01
11 / 01 -> 11 (slow/slow)    same as 01 / 01
01 / 01 -> 11 (slow/slow)

01 / 10 -> 10 (slow/nothing)
11 / 00 -> 10 (slow/nothing) sym to  00 / 11
11 / 10 -> 10 (slow/nothing) same as 01 / 10
01 / 00 -> 10 (slow/nothing)  sym to 00 / 01

10 / 01 -> 01 (nothing/slow)
00 / 11 -> 01 (nothing/slow) same as 10 / 01
10 / 11 -> 01 (nothing/slow)  sym to 11 / 10, same as 01 / 10 
00 / 01 -> 01 (nothing/slow) same as 10 / 01


period 3, 2 IN, 2 OUTs (crossover), 2nd derivative
000 / 000              -> 11  (fast/slow) "right-handed" :-)
grad up   / grad down  -> 11  (slow/fast)
grad down / grad up    -> 11  (fast/slow)
grad up   / grad up    -> 11  (slow/slow)
grad down / grad down  -> 11  (fast/fast) or fast/slow for better tracking?
111 / 111              -> 00  (super slow :-)
grad steady -> steady?

task #1: prey - food, moth like "self-guided focus", follow food, light, somehow guided delayed channel?
task #2: predator - prey, connecting two dots -> know third


see #70 
"transportation network - descrete agents (dedicated cells?) and attractant (food). Agents are looking for food 
and excrete its own attractants attracting other agents/cells" - backfeed / reflections???????

how is that beneficial - leaving "breadcrumbs" even for 00, loosing energy?

so how to connect two SMNAND cells? second level control - lower freq. Freq sum??? 
like DAC with weights - this is for momentarily signal with big range (1-150 like), but if you have 2 signals
both level 1 and over time just - 1200010000120001000012000100001200010000
actually this is wrong            1200010000120001000012000100001200010000

just freq - max freq, full speed, 11111111111111111111111111111111
slow motion                       10000000000100000000000100000000
slowing down                      11100000000110000000000100000000
"music of the world" :)


heartbeat rate >> in rate for best recognition (Kotelnikov-Shannon?)
so heartbeat - only for Cell1 (low level cells), all other cells - are delayers, above "delayed" out for 2-3-5-7 timeslices, can't grow
heartbeat - is useful for analog signals only? no, still needed due to physical friction and a need to push
everything forward or it stops :) so cell's out just opens a gate for heartbeats to push actions!?

complimentary actions can be controlled by diff cells.


??? now, smarter version In -> Cell -> Cell -> Out  or something
                            -> Cell -> 

https://medicalxpress.com/news/2019-12-key-mystery-brain-cognition-understood.html
https://www.eurekalert.org/pub_releases/2019-12/ai-vnd121119.php
https://medicalxpress.com/news/2014-09-scientists-uncover-neural-basis-confidence.html

"increasing activity when the expected reward was low" opening gate to heartbeat? 000 -> 11?

not yet, still 2D -> 2 actions, 2 cells
In -> Cell -> Out will only work for 1D

unlikely for 1 cell to directly trigger other cells action, they are working in parallel but coherently
when we're moving, we're moving in both direction simultaneously, they are counter balanced?

and/or cross-wired! like left in, right out!!! totally forgot it. is really related? works for binaural only?


Out is sending heartbeat to action cell and also to a shared cell, which reflects it back to balance out action/counter action?
are action/counter action always balanced? like 30-70 or 50-50 or may be 80/80 sometimes? often? rare?

***************** Dec 2019 ***************** 

gravity
spatial/temporal symmetry (merge/split, both combined?) - MNAND and/or MNOR for all inputs 000 or 111 
if lasted a few cycles only (avoid randomness insanity)

DO NOT train, just self-train for simplicity (IO=GF). 
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
  all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
  link (N ins, M outs), delayed out for 1 timeslice, can randomly grow/split with freq
  cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow
  reaction to signal and delayed signal - basis for pattern recognition

heartbeat - to all cells for sync? to ensure signal slicing into the same chunks? useful for analog signals only?
reflections (below)? mappings (simplified, 2 outs only with simultaneous outs possible)?

if GF is coincide with model out - issue reflections to not allow sub-models to act?
=>>> if GF is coincide = how? out - 3 levels 1/0/10, GF/In - 2 ? After 1st level processing GF/In is 3 levels too.
also freq mismatch!? => same freq may be for reflections! all 0 ins => reflection?
at IO level combine all reflactions (predictions) and compare to current IO.
Same - action approved for correct models? sample please, line & 1 in, 2 actions (L/R)
backfeed loop???

ok - 3 levels out 1/0/10 matches to 3 actions:
start action            - In all 0
continue/do nothing     - In random
reverse (complimentary action, like left-right)
                        - In all 1, saturation

why there's no endless loop in "line & 1 in, 2 actions (L/R)" situation? randomness! unlikely/almost impossible 
that reverse action will get us back to the same state even if we're at 90 angle to the line.
so, In -> Cell -> Out works for the case? yes, with processing delay (above , "delayed" out for 2-3-5-7 timeslices)
we can get "approximate movement"

now, smarter version In -> Cell -> Cell -> Out  or something
                        -> Cell -> 
to react diff to 1) line and 2) dot, differentiator - second action result (IO) is likely 0 for dot and 1 for line.
meaning our action is "second level" IO?! action(s) should be reflected back to IO level 1 or not?
we need for Cell #2 these input - from moment 1, moment 2 and action 1


but how to react? propagating reflection to the very bottom? or reaction is just another IO randomly fluctuating,
waiting for reflection when out is coinciding with GF?
as there's no memory mapping (building new cells/models instead) correct action should be decided based on what 
the best (top level) model thinks with reflections inhibiting incorrect models?

how to chain react with MN... cells? flipping?
cummulative reflecions from many models / GF hits = confidence?


if we have 2 models - reacting to red color and long tail, then for reaction to both we can either:
1) build totally new model, based on the same IO, reacting to both (waste of resources as there are many combinations);
in this case duplicate reaction possible as two models may be triggered at the same time.
2) build on 2 models out - hierarchy and works with reflection to eliminate false positives (true negatives);

to think (below): true negatives - human strength, true positive - machine/app strength
true negatives - "nezvestnoe pugaet" (Tessla :), passive/still mode? remember - random strategy, level 0.
is this "play dead" the best strategy for 1/1 model out ("unknown")? yes. Masquerade as non-living thing.
1/1 model out (no  in) - max some/random activity?
0/0 model out (all in) - no or min some/random activity?


***************** Nov 2019 ***************** 

gravity
symmetry
heartbeat
MNAND and/or MNOR for all inputs 000 or 111 if lasted a few cycles only (avoid randomness insanity)
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells, 
all models are getting the same In, 100% input duplication concept

growth when freq increase, bytes / (volume * sec)

real long links (not virtual with delay, topology) => 2 cell types:
link (N ins, M outs), delayed out for 1 timeslice, can randomly grow with freq
cell (N ins, 2 outs), "delayed" out for 2-3-5-7 timeslices, can't grow


What if we change approach entirely? create mutant-cell that can change itself a bit/adapt
and run a sandbox for a while. Hmm, we can get something working but won't know how.
Do I really care?

how - each cell self tuned? in sync with group?
how to grow/when to grow, provide sample 1 -> 2 -> 3 cells, why better?
growing during life time as well as evolutionary increasing max volume?
is growth one direction (up) or maybe with sides? should not be random, where more signals/high freq?
where existing system is overflown with events and can't respond properly/timely.
Contradiction: on lower levels model is probably 99% wrong - still grow? or there's a limit - once reached
can not grow more at that spot? actually most likely only a few cells are presenting a valid model at any given time.
so simple diff "model/cell out" vs "io" does not apply. Doesn't measure diff, just freq?
 
confirmed with #66 study - growth when freq as it increases with data stream being the same, but less volume.
bytes / (volume * sec) is up.

how - just splitting up / duplicating Out signals to new cell(s)?
no. Splitting / reducing volume coming into each direction.
sym split (50/50) or MNAND/MNOR?
what if not sym split, but 100% duplicate/copy? example?

***************** Oct 2019 ***************** 

gravity
symmetry
heartbeat
MNAND and/or MNOR for all inputs 000 or 111 if lasted a few cycles only (avoid randomness insanity)
real long links (not virtual with delay) => 2 cell types, link (1 in, 1 out) & cell
GF (in fact AKA In, see somewhere below) is a direct input to ALL cells
all models are getting the same In?

in != out, model fails, looking for addition/alteration
when in == out reflect to react?

what is "our out" if we have two? 1 is ok? (as either NAND or NOR does constitute a full basis)
or if we 'react "smoothly" (analog way)'?
how's symmetry involved?

MNAND logic: all 1111 for a few cycles-> 0 / 0, all 0000 for a few cycles-> 1 / 1, all other situations - 1 / 0?
suppose, this finds symmetry by definition

btw, 2 outs is just emulation of analog signal with 3 states/levels: 0 -> 1/2 (uncertain) -> 1
so now we can compare such "multi-out" with "real world multi-in"?
but should not replace 2 outs with 1 multi-out as loosing topology
ok, now addition / actions / symm

initial action - heartbeat, either regular or random (they are equal in a long run)
model is good if sym action -> sym reaction! even though ideally we need all 111s, but all 111s without valid action 
would result in incorrect model. symmetry must be omnipresent, even implicitly.
model - 2 inputs - our actions & In
        heartbeat -> actions initially directly
        multioutputs - each output compare with current In
        maybe wrong actions or wrong model

to rephrase - our actions are being reflected by two models - internal and external (world) and
if result is the same - model is good.
model is being constantly used for "what if" situations - same In, different actions, choose the best.

moth model? One param optimization. What about two?


*...**...***...*...**...***...*...**...***...*...**...***... 15
               | mirror       |              |               15
*...**...***...A
*...**...***...A
*...**...***...A
*...**...***...A

*...**...***...*...**...***...*...**...***...*...**...***... 15 * 2 = 30
         |         |         |         |         |         | 10 * 3 = 30
*...**...*A
**...*...*B  D
*...***...C
*...**...*A
**...*...*B  D
*...***...C

These are recurrent fractions as both In period and reflection period are integers. 
prostie chisla

other methods? "iz odnoj trybi vitekaet...."
see above, suppose, this finds symmetry by definition

now we need to build sym hierarchy, like ABC -> D???

some trivial cases:
******......   ->  *****........
                 \ ******.......

......*......  ->  *****..****
                 \ ***********

......**.....  ->  *****...***
                 \ ******.****

......***..... ->  *****....**
                 \ ******..***

***************** Jun 2019 ***************** 

1) Temporal symmetry may be tracked with OR/AND cells by sending 11 in one direction, 00 in another and
finding silence/peace in 0/1 stillness/balance. Gravity is needed to merge 1 and 0 routes.

simultaneous output in two directions:

single line temporal signal
       L    R
      AND  OR  | NAND NOR  (both complete)
0 0 -> 0    0  |  1    1
0 1 -> 0    1  |  1    0
1 0 -> 0    1  |  1    0
1 1 -> 1    1  |  0    0

DELAY is not needed as transition 1111 -> 1111 / 0000 -> 0000 is stable so it doesn't matter when we merge.
But reflections are needed at the merge point to insure that distance between the point and the source is the same.
Once we we see the same INs during heartbeat interval we should issue reflection?
there should be at least 2 or more existing inputs and at least one 111111 and one 000000
or absense of those / irregular input, like 111011 and 001000 ?
so at the merge point we expect each In to be stable (as previous) and at least one 1 and one 0?
if this is not so - send reflection?
must use '1' and '0' not 1 (signal) and 0 (no signal) or other chars '.' and '*' for example
so we can tell no input from no signal. Or maybe this is unnecessary as in real life there's no such thing as
"unconnected cell never receved a single signal" due to grow pattern "grow as needs to be". But we need to 
treat 0 signal same way as 1 - create 0 output and 0 reflections. Still '.' and '*' may be easier to implement.

"All three elements of the functionally complete set {AND, OR, NOT} can be constructed using only NAND. Thus the set 
{NAND} must be functionally complete as well"

AND, OR - incomplete, let's use NAND, NOR?
my old initial basis of "OR, AND, NOT, MEM" can be reduced to NAND/NOR, and MEM is not needed as embedded (temporal)
so elements are MNAND/MNOR?????

I think MNAND/MNOR "inversion" does not affect stability of transition 1111 -> 1111 / 0000 -> 0000 it's just flipping 
all the time 111->000>111->000 but stable nonetheless.


?? Assume heartbeat (=5-7?) > reflection distance >> tick interval = 1

and once we receive both reflections back at the same source point, then what?
action? how about subloops?

Number of Ins may be != Outs, so forcing reflections to the origin may not be feasible, but it seems that
reflections in general are required and should likely be at the same distance from origin (??)
due to natural architecture (see below, In / Proc / Out) and signal synchronization required
(only with reflection you can be sure that you're reacting on + and - signals from the same In)
so you can properly detect patterns. Though with some efforts you can achieve it with linear architecture
(and with natural selection to equalize signal routing) but reflections would make learning an instant process!?
The task is to pick up all possible (learned) patterns from the same stream simultaneously.

Note that reaction may be needed to a symmetric pattern? how if we're sending reflections for symmetry violations only?
abs sym pattern:    *************** or abs asym?
abs asym pattern:   *.*.*.*.*.*.*.* or abs sym?
sym pattern 1:      ****....****....****....****....
sym pattern 2:      ****..****..****..****..****..****..
non sym pattern 3:  ****..****..****..****...****.****..

or we react to sym pattern until we realize it's sym? how do we build/fix/rebuild connections?
build maitrix not reacting/producing reflections to pattern 1 
that maitrix would/could still react to pattern 2
so what is that about parallel processing?

logic for any cell must be unified, single cell type. Analysis logic (merge) should be same as NAND/NOR!

AA | B  B
AB | B  A
BA | B  A
BB | A  A

reaction level 1: random (best strategy/nobrainer), no improvements over time;
reaction level 2: immediate (reflex/no volatile memory), natural selection, generation improvements;
reaction level 3: symmetry (reflection/memory), natural selection + instant learning, fast improvements;

https://lenta.ru/news/2019/07/22/brain/ reacting/reflecting to symmetry (sustained for some period) to avoid 
randomness insanity?

see below, react to symmetry - same In for some time! investigate pattern 2
so every level would slow down processing? same 1111 for 3 cycles -> 0 / 0, same 0000 for 3 cycles -> 1 / 1, 
other IO 1011 etc for 3 cycles -> 1 / 0? 

or react to asymmetry for some time? naturally reaction to symmetry - do nothing? randomness insanity?
what if we react to symmetry sym -> temp and above that react to absence of temp?
how does reaction/reflection work for diff path - direct/w delay? 
in this case what about using reflections to find symmetry but when we find it then what - pass it to next level?
and what about NAND/NOR? (use for analysis) reflections (use for synthesis)?

send 2 streams up - NAND/NOR?
reflections - up -> down or down -> up or? to all directions?
reaction to symm - to the same in & reflected up (multi-ins?) or same up & reflected up?
real actions on what?

similar temporal symmetric signals:

*...*...*...*...*...*...*...*...*...
*.......*.......*.......*.......*...
*...............*...............*...

not similar

*.......*.......*.......*.......*.......*.......*.......*.......*.......*.......
*......*......*......*......*......*......*......*......*......*......*......*......
                                                        ^ low similarity

NAND/NOR logic combined with balanced reflections (react smoothly to 1/0 proportion of reflected coincidents):

1) Use NAND/NOR logic to send 2 streams up (2 channels, L&R);
2) reflect every downstream;
3) compare reflection / current value for both "channels" separately and react "smoothly" (analog way) based on
proportion of coincidents (same values). Ex:
all coincidents are on L channel => 0  or -50
all coincidents are on R channel => 100  or 50
coincidents are 50/50 on L/R channels => 50 or 0
max reaction to 0 in or min reaction to symm?

need real long links (not virtual with delay) => 2 cell types, link (1 in, 1 out) & cell
and we don't need in-cell memory!

min reaction to symm => multi-reflections?
rather max reaction to 0 => and maybe send multi-reflections? same as all 111-ins reflections.
what will be the result of multi-reflections? 
should multi-reflection be 111 or 000-type or both? how upcell knows channel type and why?
this could only increase chances of coincidents (=> action) down-stream? no guarantee at all.
btw, sending one type, 111 only, would increase the chances of action even more?

goal - 1111 (or 000 for someone), means - symm via action, action likely to be in counter sync with symm? 
111 or 000 - is the final case, 1010 symm - balance (model), mix model and random 10111001 - reality,
all models symmetrical by definition, many cells, many competing models even with single IO
EDGE case - where the model breaks! => new, better model maybe
"how to eat/cover full square?"
start with "almost" straight line model 01010101010 action => 101010101010 IO expected (left side line)
                                     if 01010101010 action => 010101010101 IO expected (right side)
btw, this depends on action's efficacy/stability,             
for example could also be like this     11001100110 action => 001100110011 IO expected (left side line)
                                        11001100110 action => 110011001100 IO expected (right side)

"dotted" straight line model            01010101010 action => 100010001000 IO expected (left side dotted line)
                                        01010101010 action => 000100010001 IO expected (right side dotted)

curved line model (or solid space)      11111111111 action => 111111111111 IO expected (left side curved line)
                                        00000000000 action => 111111111111 IO expected (right side curved)

two sided-tunnel (or solid space)       01010101010 action => 111111111111 IO expected (both sides)

example:
1) have generator 1010, linear "almost" straight input 1010 (left side)
in == out, identical, so generator is a model for "almost" straight input 

2) change "almost" straight input to 0101 (right side)
in != out, model fails, looking for addition/alteration
adding 1 cell (reversing in), 
now in == out, identical, so generator with 1 cell is a model for "almost" straight input (right side)

3) line turned left instead of #2
new model - grow as we randomly add new actions/cells to old model till get back on track! 


keep In feeding both models, first - failing, so not affecting actions
second - working, actionable

GF (in fact AKA In, see somewhere below) is direct input to ALL cells?


what is "our out" if we have two? 1 is ok? (as either NAND or NOR does constitute a full basis)
or if we 'react "smoothly" (analog way)'?
how's symmetry involved?

or hierarchical network where action is accountable? but where is symm then?
and how do we grow/learning new?

var A:
reflect any in all directions, when up NOR 1 = reflected up NOR 1 - action and 0 NAND up = 0 NAND reflected?

var B:
reflect any in the same direction, when up NOR 1 = reflected up NOR 1 - action and 0 NAND up = 0 NAND reflected?


***************
__***************     delay 2
___***************    delay 3
_____***************  delay 5


***..***..***..***..
__***..***..***..***.. delay 2

***..***..***..***..
_____***..***..***..***.. delay 5

*.*.*.*.*.*.*.*
__*.*.*.*.*.*.*.*   delay 2

*.*.*..*.*.**.*.*
__*.*.*..*.*.**.*.* delay 2


  further analysis?
  .
  |                      .
 / \                     |\
/   \                    | |
\   /                    | |
 \ /                      \|
  .                        .
  In                       |  
                           Out action?


normal brain stucture:

                 processor (reflections)
                 /\ /\   /\
                |  |\ \  \/ _________Out2_____
_______In1_______\/  \ \ |___________Out2_____
_______In2____________\/ |
_______In3________________


still needed two different types of elements - MNAND/MNOR (1 In, 2 Outs) for analysis
and R??? for synthesis (2 Ins, 1 Out or 2 Outs like combined with MNAND/MNOR?)
No, only one combined MNAND/MNOR element with many Ins/2 outs

In1 In2   Out Reflection   NAND NOR
0 0 0 0 -> 0    0           1    1
0 1 0 0 -> 1    1           1    0
1 0 0 0 -> 1    1           1    0
1 1 0 0 -> 0    0           1    0

0 0 0 1 -> 1    1           1    0
0 1 0 1 -> 1    1           1    0
1 0 0 1 -> 1    1           1    0
1 1 0 1 -> 1    1           1    0

0 0 1 0 -> 1    1           1    0
0 1 1 0 -> 1    1           1    0
1 0 1 0 -> 1    1           1    0
1 1 1 0 -> 1    1           1    0

0 0 1 1 -> 0    0           1    0
0 1 1 1 -> 1    1           1    0
1 0 1 1 -> 1    1           1    0
1 1 1 1 -> 0    0           0    0


output polarization is not important? I & O may be sent opposite or just different directions 
with some gravity gradient?


2) structure can be improved via competition and natural selection only.
Temporal networks actually have defined structure, the topology is not flat as with only 1 IN & 1 OUT we need
some non-trivial topology.
 
3) always interact. IO may also be dependent on our response, SINs as we change environment;

4) simpliest model 1 IO = GF, later GF is more like internal energy status. Random strategy is the best in the case;

5) assume temporal symmetry for now, spatial may be added later on as parallel routes;

6) heartbeat is needed to implement 


***************** Feb 2019 ***************** 

https://lenta.ru/news/2018/12/21/mold/
must solve NP-hard problems for polinomial time (even a bit sub-optimal), ex. TSP

0) structure can be improved via competition and natural selection only!
structure depends on cell division rules so improved sructure means/requires better rules?
while structure is mostly prebuilt for a single being, it is a bit flexible to justify M1/M2 difference/advantage

can structure (#24, todo) be only grown with external correction/in competitive environment?
is that different from self-teaching somehow or not?

and that is initial goal. And once we have quite adaptive structure we can move to teaching

interestingly enough in maiTrix there's no structure - it's flat, can't be changed or 1 moving uplink is
analog of changing structure? I think it is, but we need to maintain structure by allowing only slow changes!? how?
structural changes for Gf -1 and (&&) new signals/mappings only? 
what about M1/M2/.../MX compare and survival rate? new cells only, hm?

basic processing element structure/logic - cell remains pretty much the same since the very beginning, with evolution
we may a) grow volume  b) tune up/optimize internal settings - rnd, vars, delays c) grow meta-structures
once built in 1 maitrix, the structure is difficult to change/remove, there may be only additions.
after M1/M2/.../MX competition the whole structure survives => copied/cloned to move on.


1) always interact. IO may also be dependent on our response, SINs as we change environment;
2) simpliest model 1 IO = GF, later GF is more like internal energy status. Random strategy is the best in the case;
3) spatial/temporal symmetry (merge/split, both combined?), start with 1 IO cell;
4) 1 -> 0 and 0 -> 1 transitions needed, avoid "total randomness" problem with sleep (establish 0->something, rather 
than random, based on the most probable reflection? if this random is not leading to GF > 1?);
5) DO NOT train, just self-train for simplicity (IO=GF). 
Training just improves progress (and establishes common language).
Learn by example - "focal depth" - a range of singular cells highlighted when all objects of similar class are being
reflected.
6) heartbeat is absolutely needed (defines symmetry) > 1 tick = length of "small closed split/merge system"?
to discover law/symmetry divide/multiply IO and compare to heartbeat?
implementation - 2 elements min
7) -1 Gf should result in CREATING mappings and can remove on +1 GF.
if there are a lot of mappings and unlikely if there are a few (but basics?), "true negative feedback cycle"
in hu for reliability many cells are being used working in sync for critical info

or on Gf -1 memorize and immediately starting to remove that mapping on +1s, unless reinforced = repeated & connected?

it works the other way too - memorization should create +-GF to sustain itself every time/every refresh, 
otherwise it will fade.

every access would result in adding/modifying connections?
remove not mapping, but downlink connections?

Each real world concept is being mapped into a set of cells and those are not fixed, changed a bit when recalled #-3
and once changes are min / going down - we learned?


why new needed? hard to modify/remapping existing? looks like just connectivity issue - new "context" may only be
accounted by old cell if only signal has been delivered to it, so it's easier to create a new cell with all relevant
signals as IO (and maybe connect to older "similar" cell too)

new cells and connections grow pattern - however connections grows early and then extra only being removed but cells
continue to grow

min size in terms of both cells / connections even though our connections are free - would help with structure.
How to minimize? either build less from the beginning or build more and remove ineffective cells/connections.


8) same in => same out with ?99% is health norm, 50 or 100 is not, "health cycle".
we don't really need to check it as computer's hardware is much more reliable (?) but we probably need to set
margin of error to 99.9% (?).
9) +-1 Gf affects mapping of active cells only

why there's only 1 axon?? maybe attached to several n?

1 cell => 1000 connections, so with 1 -> 8 immediate up/downlinks we should have at least 3-4 levels in between
to form proper meta-structure? = 30x30, quite sparse


10) Sleep role useful in general - reflections/recreating situations in combinations => 
similar effect as from real situations => new associations, related to reinforced learning?

But actually this process does not require sleep, just may be less intense/prominent?

however sleep is important for removing mappings/cells, see #43

Two stage process (short/long term memory) is a result of self-meta-resructuring during evolution and should not 
be forced / imitated?


11) remove dead cells to self-clean is important, maybe in sleep, see #43 cells or connections only?

12) min - two cells, one - colleting data from outside => action, other - from inside (power level) => GF
so maybe GF is not like "delayed feedback" but it's affecting decisions in every single cell?
like 

no food \_ move    food    \_ eat    no food     \_ move   food        \_ stay   plenty of food \_ replicate 1=>2
hungry  /          hungry  /         not hungry  /         not hungry  /         not hungry     /

this is better than stage 0 random choice, and optimal logic (optimized with 1/1 compare during evolution)

=> if any situation/combination (external IO) is distinct (requires different action) and gives us any evolutional 
benefits then it will be memorized (by those who gets the benefits!)

complex IO triggers less response as it's more selective, #44


Some of the IO combinations are being wired to Gf directly? 
min - two cells, one - colleting data from outside => action, 
other - from inside (power level) and ****rarely**** outside (powerful/critical triggers) => GF


13) how reflections are useful specifically, for simple networks? 
if Gf is part of IO then reflection to certain directions should trigger back-Gf, emotion
and the more we get +1s the likely we do it?

#49 3000 cube, 40% syn replaced daily (?)
should sensorimotor integration be implemented via downlinks / reflection to IO level?

Dynamic logic to replace 1:1 match (combinatorial complexity - infinite) with hierarhical meta match, patterns like:
seeing one line, size 10, angle 20 => match

and minimally we need:

2 downlinks, 1 real, 1 heartbeat, may be omitted, emulated
4 distinct uplinks, reaction to *, **, _, __

or

3 downlinks, 1 In, 1 In/Out, 1 heartbeat, may be omitted, emulated
4 distinct uplinks, reaction to *, **, _, __



***************** Nov 2018 ***************** 

all split connections unlikely to merge into a single cell even within the same "small closed system"
=> "small closed system" / ranking meaningless?
__suppose __ all split connections merge and we combine output what are the benefits? slowing rate?
note that asymmetric split/merge logic is assumed.
Split is already a diff. reaction to 2 consecutive signals. This way we may react to 3-8 even more slowly? why?
merge should be 1, 2 or 8 times slower?
maybe goal is to make sure all split routes are converged and slowness is just an implication?

purpose of reflections / gf?
need In ranking?

general task - take such actions (SINs) to max IO 1 events?  probably min # of actions?
min system 1 IO, 1 SIM, 1-D field, like
.  .   .    . . .   .            I         ..  ... .. . ... ..... . . .....
start - no IO => random, found IO, associate [what] with current SIN? memorize all SINs leading to this?
positive feedback? so we need to find correlations between our actions (SINs) and IO?
or IO / reflection(s)?
to create correlation IO => SINs? min #IO 2? how to correlate one IO with another older IO? 
another memory or deviation on repeated signals is already kind-of delay?

set of different length waves can emulate any wave

https://lenta.ru/news/2018/12/21/mold/
must solve NP-hard problems for polinomial time (even a bit sub-optimal) / remove dead cells to self-clean
how to solve TSP, where is prediction /symmetry in TSP? we always care about resource (travel time) optimization.
Note: prediction to t+NN = understanding past (up to t-NN) and correct reaction to t-0 events.
Correct reaction (like min/better choice) is optimization.

problem is how to fix mapping at t-N moment when IO 1 comes? what is N? may vary per system/situation/etc. 
how/why "unfix" mapping at t-N moment when IO 0 comes? what is N? Should be determined from experience? yes.
The more IO is getting closer to SIN => less N? save on GF +1 or erase on -1? 
save always, erase when -1. keep older, most tried and true patterns?
do we really need N memory layers per cell or N cells with 1 layer is ok?

===> true negatives - human strength, true positive - machine/app strength
so maybe just with time if there is no IO at all (Gf<0) for specific cell all created earlier mappings are being erased
one by one, in the order they were created? no memory in cell needed? just Gf regulated.
https://lenta.ru/news/2018/12/28/neurons/
while sleeping we try to touch all cells to
avoid that? and with 20% of total energy consumption brain seems to be working under 100% usage/load.
does "true negatives discovery" implies XOR cell functionality? we can emulate this already.
IO to the cell or GF or both?
so we're keeping mapping for all IO leading to GF -1 and having troubles to memorize all reasons for +1?

how to distinguish good working cell from damaged? on the same input good one should give the same output over time,
unless after long GF -1 period?  not neccecary two diff cells would give the same output to the same input though.
could we use heart beat for that test?

https://lenta.ru/news/2019/01/22/autism/ repeated behaviour? +1/-1 Gf balance does not affect repeated behaviour.
and does that mean 100% accuracy (same in => same out) is not needed? 50% - Alzheimer's, 100% - autism, 90% norm?
and that -1 Gf not affecting "correction cycle" is the reason for the problem (autism).

Noether's theorem: symmetry defines invariant regarding specific change type, like conservation law of energy states 
that the total quantity of energy in an isolated system does not change. So conservation of energy follows from 
the time-invariance of physical systems.

https://lenta.ru/news/2019/01/22/human_vs_monkey/ sync
a few patterns - reliable 
many - less sync, less reliable


***************** Aug 2018 ***************** 

Recap/digest:

1) always interact;
2) simpliest model 1 IO = GF, later GF is more like internal energy status. Random strategy is the best in the case;
3) spatial/temporal symmetry (merge/split, both combined?), start with 1 IO cell;
4) 1 -> 0 and 0 -> 1 transitions needed, avoid "total randomness" problem with sleep (establish 0->something, rather than random, based
on the most probable reflection? if this random is not leading to GF > 1?);
5) DO NOT train, just self-train for simplicity. Training just improves progress (and establishes common language)
Learn by example - "focal depth" - a range of singular cells highlighted when all objects of similar class are being reflected.
6) Do no self-train initially, should be ok with IO=GF.

re #4:
sleep => no input => gf = -1 => generate random 0->1 reflections and actions => once IO/gf = 1, memorize?
1 -> no actions?

model - IO 1 bit, SIN 1 bit (L - 0, R - 1)
virtual 1-D field  0101010101010101 ... I ... 0101010101010101

IO   0101010101010101 -> 1010101010101010 -> 1110011111101111 -> 1110111111110111 -> 1111111111111111 goal
SIN  1111010011110111 -> 0001111111000110 -> 0000000100001001 -> 0000000010000001 -> 0000000000000000 goal unrelated?


sample 1:
1-DF 00000000000000000000000000000001 ... I ... 10101010101010100000000000000000

IO   1000000000000000  000000000000000010101010101010100000000000000000  goal achieved, max 1 collected
SIN  0000000000000000  111111111111111111111111111111111111111111111111

alternative:

IO   1010101010101010  000000000000000000000000000000000000000000000000000  1000000000000000  goal achieved, max 1 collected, more steps
SIN  1111111111111111  111111111111111110000000000000000000000000000000000  0000000000000000

there may be more, with different SINs
what is interesting - IO may also be dependent on our response, SINs as we change environment
1 cycle memory is not enough? closer to SIN, more recent memory use
need to correlate SIN -> IO via reflections? how temporal reflections work? They do NOT yet.
reflections needed for teaching only? For self-learning. Teaching should do ok with IO -> SINs.

Thus associations (CELL) can help with finding spatial patterns. How temporal associations work?
There are no temporal associations, they are dis-associations / splits and they can help with
finding/recognizing different temporal patterns. And we know the goal - best pattern 111111 so?
single IO cell signals are being mapped into a set of single spatial CELLs, no multiple cells activated in the same tick.
is that good or bad or irrelevant?

111001

. -> . -> \      /
 . ->     -} -> {-
  . ->    /      \
      

IO -> SINs correlation with delay?
are associations/classifications enough?
how to find temporal patterns/symmetry? split temporal => spatial and extract symmetry
but "no multiple cells activated in the same tick"
second level reaction when merge into 1? and split again?
does this help with recognizing multiple combinations?  . .. ... vs .. . ... ? time -> geometry?
.. contains . so we get both responses, hmmm
... contains .. and . so we get three responses, hmmm
how to recognize patterns? spatial - easy, CELL level, symmetry

................. global heartbeat = sampling rate??!

. . . . . . . . . => ? center focus (A/0/A/0/A/0), stable - symmetry
.. .. .. .. .. .. => ? focus shift (A/B/0/A/B/0/A/B/0), stable - symmetry

compressing intervals:

_|_|_|_|_|_|_|_|_|    AB, 0A, B0 | AB, 0A, B0 | AB, 0A, B0   -> CDE | CDE | CDE | CDE  -> F | F | F | F
|_|_|_|_|_|_|_|_|_|   B0, AB, 0A | B0, AB, 0A | B0, AB, 0A   -> ECD | ECD | ECD | ECD  -> F | F | F | F ? or G?

__|__|__|__|__|__|    AB0 | AB0 | AB0 | AB0 | AB0 | AB0 | AB0
|__|__|__|__|__|__|   B0A | B0A | B0A | B0A | B0A | B0A | B0A

___|___|___|___|___|  AB0A, B0AB, 0AB0 | AB0A, B0AB, 0AB0     -> FGH | FGH | FGH | FGH
|___|___|___|___|___| B0AB, 0AB0, AB0A | B0AB, 0AB0, AB0A     -> GHF | GHF | GHF | GHF

doesn't matter how to sample, there's period!

...... ...... ...... 
_|_|_|_|_|_|_|_|_|_|  AB, CD, EF, 0A, BC, DE, F0 | AB, CD, EF, 0A, BC, DE, F0 -> GHIKLMN | GHIKLMN
|_|_|_|_|_|_|_|_|_|_| BC, DE, F0, AB, CD, EF, 0A | BC, DE, F0, AB, CD, EF, 0A -> LMNGHIK | LMNGHIK


vs

.. . .   ... .. . => ? focus is fluctuating (A/A/0/B/C/C/0/0/0/C/A/0), no period

we already do sampling - "split" operation merges IO for 2 cycles. With that we can map all temporal IO
signals uniquely to spatial.

If we somehow rank IO links we can use this logic:
high rank signals are present (=> long uninterrupted IO) - do nothing
low rank signals - change output, randomly or just correlate more lower rank => more changes?
how do we do the ranking?

relatively easy for "small closed split/merge system" by sending signals .  ..  ...  ....
most often (read: vs heartbeat) used in-direction = low ranked

logic seems weird - ignore high ranked signals, do nothing? what is ok, as for the edge cases we actually do that:
nothing for high ranked, random search for low ranked, but what do we do in between?

     

***************** May 2018 ***************** 

Can we combine temporal/spatial symmetry? Or temporal symmetry should only by applied to cells with 1 in?
Separated as mixed mode can not be properly trained, unless we add shape[] for temporal mapping, extra memory/complexity.

1) initial mode (got none or one signal) - undefined;
2) initial mode (several signals) - spatial;
3) got signal from different downlink - spatial;
4) got signal from the same downlink twice in a row - temporal (deviation != 0);
now cell with imprinted temporal symmetry should reject signals from all different downlinks, no output produced (to allow auto-rerouting).

t1: 7 t2: . t3: 7       => 11, 0, 11    , type NEW_CELL
t1: 7 t2: . t3: . t4: 7 => 11, 0, 0, 11 , type NEW_CELL
t1: 7 t2: 7             => 11, 12       , type MEM_CELL 
t1: 5 t2: 5             => 0, 0
t1: 8 t2:               => 0

or

t1: 7 t2: . t3: 7       => 11, 0, 11, type NEW_CELL
t1: 9 t2: 7 t3: .       => 13, 11, 0, type SYM_CELL

or maybe? no

t1: 7 t2: . t3: 7       => 11, 0, 11    , type SYM_CELL
t1: 7 t2: . t3: . t4: 7 => 11, 0, 0, 11 , type SYM_CELL
t1: 7 t2: 7             => 11, 12       , type MEM_CELL 


more memory needed for training longer than 1 input cycle?
in fact yes, but not now as we need to simplify everything and DO NOT train, just self-train.
maybe keep (new) memory for as long as we're far away from the top? at posZ 10 we keep it for 10 cycles.

need strongly typed cells - repurpose GOOD_CELL / BAD_CELL or leave as is for backward compatibility?

training != self-training? re-learning? how? complete temporal reflection - what is that? 1.1.1.1. all the time?
better reaction to continuous feedback? if interaction is continuous how do we learn? it can't be 100% temporal?

gf - input 1/0
sin - control

if we have only 1 period memory, how to respond to 1111000? keep forever/a while and rollback all of them?

the model doesn't work for trivial case:

L  R
 \/
 /\
 \/
 01

not enough cells or wrong model? even with more cells you can't change out/action (free will) without input

need +/- feedback for generators?

random uplink in the absense of signal?? abstract model of biosystem is lacking that? randomness is a good strategy in general?
noise/randomness at cell level, 2-3% != randomness needed at action/uplink level, 50%? 
how to amplify randomness? sequential linking may not work due to stabilizing force of gravity?
only +/- feedback, how? or new cell type? maybe we need generator, not randomness? what's the diff? random generator is just complex generator?

consider 0 just as another signal and so recalculate output every tick? should result in 2-3% randomness without external IO?
will this destabilize the maitrix? how does it work with temporal reflection?

re lenta.ru/news/2018/06/26/brain/ looks like cells are signal-hungry and trying to process signal passing nearby even if did not normally
do that before. Can this be the source of randomness? q - if nearby cells are stimulated all the time, why they are not all interconnected
already?? answer - connections are fluid, signals form new connections, and connections are dropping in the absense of signals.

could this drop help with relearning? are real signals more analougus in nature or there are trigger levels, like DAC/ADC?

bug searching light - simplest model:

1) light    - do nothing
2) no light - random LR       
implemenation? LR0, zero uplink possible?

seems like the best min strategy (if random crawl is covering 360? no, best ever without internal model), and better than just L, just R?!
better be 100% random, otherwise may be victim of smart predators.

how to build any/min model? reduce randomness. just remember SIN uplink for good gf (input 1, there's only 1 IO cell!).
generate random link to LF and seeing 1 IO (gf, in fact) we would fix/memorize the whole chain? the last step(s) only as "light - do nothing"
===> ACTUALLY gf != IO, gf is more like "hunger", "energy level", etc

bug searching light - corrected simplest model:

1)    light - gf >  0 - do nothing
2) no light - gf >  0 - for some time, do nothing      
3) no light - gf <  0 - random LR as IO 0 with gf -1 may be -> 1? actually with gf -1, 0 -> 0/1/random uplink, 50/50% or 0,1,2,3,4,5,6,7,8 even?
4)    light - gf <  0 - maybe for some time (faster)?

kind of - absence of input = random input (with gf -1 only) ? just for IO or all cells? looks like all cells would give us better randomness?
right, however it would also produce random output even though we have some decent model of the situation? => for SIN cells, not IO or all cells?

L  R
 \/
 /\
 \/
 /\
 \/
 01

bug searching light - more advanced model:

1)    light - gf >  0 - do nothing
2) no light - gf <  0 - random LR, memorize the path
3)    light - gf >  0 - do nothing, fix/rememeber the path
4) no light - gf <  0 - repeat last path
5) no light - gf <  0 - random iteration over all possible last paths? 
6) no light - gf << 0 - random LR as a last resort, goto #2

implemenation? what is the path - not only sequence of SIN, LRs, LLLRLRRRLRLRR but all path from the bottom
so 0 is not absence of 1, just another signal, like 1/2 or 
add clear 1 -> 0 (easy, sometimes 0) and 0 -> 1 (???? when ALL downlinks 0) random mapping

Also Cell implements OR / AND operations naturally, but not NOT and we need it? We do.
is it really useful without MEM / delay and feedback loops? maybe, if we recalculate uplinks with every tick?

"random totality problem": allowing 0->1 transition at all levels, outcome is totally random... what is good for simplest model, 
but this model is the slowest. timeout? learning / learning?

once new cell created (!= NO_CELL) we fix reaction to 1, but need to learn how to reacto to 0 too, 2 types of training? or sleep?!


***************** Mar 2018 ***************** 

learning strategy:

always interact! This should remove blind spots with any input data bandwidth. Also means we rely more on temporal symmetry, not spatial.
LRUDBF scan. Tracking certain uplink on the last level can be done via single output on IO level so each S cell creates 8 unique outputs.
What outputs should be assigned to LRUDBF actions and when? Every time we grow we create new S/outputs.

As we grow we have more SINs (from every level).

GF should be different (global max/mix), not lesson goal. Although they may coincide, but no need to force teaching, just help.
Global goal - at every single training level we need to get reflections as close to input as possible with min output (SIN).
Local goal - these min outputs / reactions may be different for different maitriXes and while it's ok we want to unitize them as
a common language.

reflections similarity is easy to check, but what is min output? min over time period - predictions?
minimize <<<# of cells>>> keeping all back reflections? EQ = predictions? EQ =? Min # of cells over a group of maitrixes? Evolution?
DAC puzzle - works ok (like any computer), but not optimal
info is being minimized by default/construction as every element reduces/does minimize info.

Simple sample - Turing tape with b/w dots, find more dots with min moves. Can move L/R. Input - single IO.
Advanced sample - 2D & LRUD / LRUDBF.
Basically no need to train here ever, as GF is already correct, training just improves progress (and establishes common language).

MUST ALWAYS COMPARE WITH PREVIOUS INPUT! Should compare current downlink and one from memory. X + sym X?

spatial symmetry  - merge
temporal symmetry - split?

         __________
    ____/    ______>------
---<________<_________/



***************** Jan 2018 ***************** 

teaching strategy:

a) present lesson

evaluate over a certain period:
b) if response is not changing, a- a- a- a- a, expecting x
c) if response is the same wrong set (more loose criteria than [a], allows variety), a-b-a -c-  c- a-a-   a, expecting x
d) if response is good but at wrong position, ' x- x-   x -  x', expecting 'x'
(can't really agregate them without reducing alphabet size?
and we probably can! if we grow and connect them!)

controllable growth?   
/\ \   /\/
\ \/   \/
/ /
\/


I) reverse training (sleep phase), fix reflections for one SIN and another one, resend them both, see a/b/c 
problem is - do it immediately when separate (but in fact related) SINs are discovered or once ("a day") for all, how to do it properly
how to distinguish "separate but related" SINs and grouped/linked SINs (used for advanced output, beyond 8 bits?)

q. - how to do reverse training for "perception cone" middle slice? like pos 10 of 70, with 5 greens (valid!) / 2 reds?
capture both reflections for 5 greens and 2 reds, repeat reflected input for 2 reds till get reflections for 5 greens back? and nothing else?!
well, we need to get those reflections back from the slice! Can't wait till we reach the very top as reflection from there is too generic.
can't grow in the middle? ;-(  only top (where diamond grow can make sense)

?? "learn by example" - always send known item (along with one to learn) to get back reference reflection
or rolling alphabet? is it always possible or may fail due to oversaturated cells?

implementation:

a) show existing example
b) notice "focal depth" - a range of singular cells highlighted when all objects of similar class are being reflected
   ? to do that we need to save "all objects reflection" with the lesson or just layer's start/end pos?
c) show new example similar to the shown
d) make sure its path (red) would hit any singular cell along "focal depth" path

q. - there's only a certain amount of new things may be learned (more with longer "focal depth") under single "classification/association" branch
what is probably normal, we need to come up with better classification if exisiting one doesn't work well anymore?


with the logic we can grow/learn 8 groups of ANY size, but what about 9th group? Sure. Just 1st item in each group should be
associated with any exisitng group/groups. Other items will be associated with the 1st one. If two groups are not associated/related
this may be ok to have two SINs? first item in the group - (re)action. Can't change reaction to 2nd group only, alwayds 1st / 2nd combo?
how to establish relations between different groups? means hierarchy, can we go both ways - from simple to complex and other way around?


\__  
/  \__ Combine two groups into 'generic' group. 
\__/   Present two groups (actually any single item from one group and another) at the same time and
/      do the training till these two (ond only two) reflected for some period (>1 tick?).

actually there's no need to present second item, we just need wait and see when it's reflected
however this is just a slow random walk and by sending second item we may help in finding the right way faster
(red should stick to existing green path? even though lagging behind, timing issues)



\
__/  split one group, requires mapping changes. Present one group, train till each one is reflected as SIN?
/ \


when looking for "focal depth" - can't rely on layer pos only, need to know precise cell location?


***************** Dec 2017 ***************** 


==> must judge by comparing expectation vs actual. Expectation depends on lesson, like simple lesson requires Y/N, more tricky - "abc" response
what sets "output level" in the perception cone
expectation < actual, need for reverse training to sharpen the cone
expectation > actual, grow at the bottom to enlarge the cone

if "perception cone" output slice gives us 
  a) valid green and red or just red => do reverse training to merge them  
  b) wrong green or wrong green / reg
  we need to overcome saturation (when cells can't produce unique output)


goal - improve process convergence by either of and/or combination:
expand - there are always red channels (more often in the middle, but can be end to end) and we want to correct/improve them

g-g-g\__g_g_g____
r-r-r/   _r_r_r__\__r_r_r_[top]
g-g-g-g\/
r-r-r-r/

ideally we should repeat the same path while gf < 0 trying to correct path near the top first and then moving to the bottom
randomly with gradient * discontent (set externally, or gf -100, -1000)
do not erase uplink, but mapping (erase randomly as above)? distance is not needed?


0) for -1 gf erase mapping, but not all uplinks, randomly with gradient proportional to discontent (gf -1 ... -100 = erase all uplinks)

NEED to find out on what level we turn green!

1) for -1 gf mark red path as green, except for the very last segment (adjustable) before green path
con: may create green channels leading nowhere (less space for maneuver later on?)

2) save red tracks (for 1 cycle only?) so they may be easily retraced and improved
this is how it works already!

3) there's no continuous metric to estimate convergence, it's ether 1 or 0 so not enough feedback to adjust properly
pro: simple metric is easy to implement
con: less obvious how to use it (small distance - change only at the end? how to retrace - same issue as #1? can use with #2?)

4) crazy - grow channels from both ends, top and bottom as top is very tight place and hard to reach from the right angle
con: difficult to implement? as don't know what output should be. Can #3 help?
con: meeting in the middle is as difficult as in the end

5) grow from the top to create more space
pro: easy to implement, needed anyway
con: add time to relearn (need repeating lessons)

6) change gravity to avoid conglomerations? antigravity
pro: might help
con: defeats the very idea of gravity as uniting force

7) change learning strategy - if can't learn - skip for now to get back later
pro: easy to implement
con: does it help?


***************** Jun 2017 ***************** 


check reflection's uniformity for verification? 
or redirect it back for self-learning, positive feedback?

growth criteria? grow on what end?

maiTrix completeness criteria - Sins.complete, expected, etc to remove/change?
each iteration is a long one (see above "impulse oriented"), wait z-size period;

for -1 modify shape based on reshape this way:
for all cells in reshape (where we keep only "choice" cells for current run) 
we recalculate uplink as described in axial reflections above;

to think of - is there such think as importance rating for input? 
So in that case we can allow maiTrix to readjust itself in the way
it would generate ~0 reflections up untill the very end? Like a direct
reaction channel on important input. 


***************** Jun 2016 ***************** 

Watson Technologies, ii, Boston?
